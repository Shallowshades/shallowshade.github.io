<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>未名的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="慕然回首，你是否看到过去的自己">
<meta property="og:type" content="website">
<meta property="og:title" content="未名的博客">
<meta property="og:url" content="https://shallowshades.github.io.git/index.html">
<meta property="og:site_name" content="未名的博客">
<meta property="og:description" content="慕然回首，你是否看到过去的自己">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="未名">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="未名的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">未名的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://shallowshades.github.io.git"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Linux" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/12/13/Linux/" class="article-date">
  <time datetime="2022-12-12T16:00:00.000Z" itemprop="datePublished">2022-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/12/13/Linux/">Linux</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Centos"><a href="#Centos" class="headerlink" title="Centos"></a>Centos</h2><h3 id="修改用户名"><a href="#修改用户名" class="headerlink" title="修改用户名"></a>修改用户名</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 登出要修改用户名的用户（没有注销登录的用户无法修改）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到root账号修改用户名和用户根目录。</span></span><br><span class="line">vim /etc/passwd						# 修改用户名和用户根目录,修改内部全部的oldname为newname</span><br><span class="line">vim /etc/shadow						# 做法同上</span><br><span class="line">vim /etc/group						# 修改用户组，将用户组名改为新用户名</span><br><span class="line">mv /home/oldname /home/newname   	# 最后，修改用户根目录名</span><br></pre></td></tr></table></figure>

<h3 id="修改用户密码"><a href="#修改用户密码" class="headerlink" title="修改用户密码"></a>修改用户密码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su root 				#切换到root账号</span><br><span class="line">passwd username 		#修改密码</span><br></pre></td></tr></table></figure>

<h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">:w 				-保存文件，不退出 vim</span><br><span class="line">:w file 		-将修改另外保存到 file 中，不退出 vim</span><br><span class="line">:w! 			-强制保存，不退出 vim</span><br><span class="line">:wq 			-保存文件，退出 vim</span><br><span class="line">:wq! 			-强制保存文件，退出 vim</span><br><span class="line">:q 				-不保存文件，退出 vim</span><br><span class="line">:q! 			-不保存文件，强制退出 vim</span><br><span class="line">:e! 			-放弃所有修改，从上次保存文件开始再编辑</span><br></pre></td></tr></table></figure>

<h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><h3 id="ssh"><a href="#ssh" class="headerlink" title="./ssh"></a>./ssh</h3><table>
<thead>
<tr>
<th>文件名</th>
<th>用处</th>
</tr>
</thead>
<tbody><tr>
<td>authorized_keys</td>
<td>存放授权过的无密登录服务器公钥</td>
</tr>
<tr>
<td>id_rsa</td>
<td>生成的私钥</td>
</tr>
<tr>
<td>id_rsa.pub</td>
<td>生成的公钥</td>
</tr>
<tr>
<td>known_hosts</td>
<td>记录ssh访问过计算机的公钥（public key）</td>
</tr>
</tbody></table>
<h3 id="密码登录"><a href="#密码登录" class="headerlink" title="密码登录"></a>密码登录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/ssh/sshd_config	#修改ssh配置文件</span><br><span class="line">PasswordAuthentication yes		#在#Authentication下面添加，之后可以使用密码登录</span><br></pre></td></tr></table></figure>

<h3 id="免密登录"><a href="#免密登录" class="headerlink" title="免密登录"></a>免密登录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen							#本地使用该命令在usr/.ssh/下生成公钥(id_rsa.pub)和私钥(id_rsa)</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.ssh/authorized_keys			<span class="comment">#远端,打开文件后,将生成的公钥写入</span></span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="https://shallowshades.github.io.git/2022/12/13/Linux/" data-id="clca7m48h000fxog059ezfc5q" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Redis" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/12/13/Redis/" class="article-date">
  <time datetime="2022-12-12T16:00:00.000Z" itemprop="datePublished">2022-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/12/13/Redis/">Redis</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>基于内存的键值对存储，因为是基于内存，所以比数据库基于磁盘快的多</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc tcl			<span class="comment"># 基于C语言编写，需要安装gcc</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src</span><br><span class="line">q			<span class="comment"># 解压安装包</span></span><br><span class="line"><span class="built_in">cd</span> redis</span><br><span class="line">make &amp;&amp; make install			<span class="comment"># 运行编译命令</span></span><br></pre></td></tr></table></figure>

<p>默认的安装路径是在 <code>/usr/local/bin</code>目录下，该目录已经默认配置到环境变量：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>用处</th>
</tr>
</thead>
<tbody><tr>
<td>redis-cli</td>
<td>redis提供的命令行客户端</td>
</tr>
<tr>
<td>redis-server</td>
<td>redis的服务端启动脚本</td>
</tr>
<tr>
<td>redis-sentinel</td>
<td>redis的哨兵启动脚本</td>
</tr>
</tbody></table>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">redis-server					<span class="comment"># 默认启动方式，前台启动</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src/redis			<span class="comment"># 进入配置文件所在的文件夹</span></span><br><span class="line">cp redis.conf redis.conf.bck	<span class="comment"># 备份，以免出错</span></span><br><span class="line">vim redis.conf					<span class="comment"># 添加以下内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改为0.0.0.0可以在任意IP访问，生产环境不要设置为0.0.0.0</span></span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line"><span class="comment"># 守护进程，修改为yes后即可后台运行</span></span><br><span class="line">daemonize yes </span><br><span class="line"><span class="comment"># 密码，设置后访问Redis必须输入密码</span></span><br><span class="line">requirepass 123456</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选内容</span></span><br><span class="line"><span class="comment"># 监听的端口</span></span><br><span class="line">port 6379</span><br><span class="line"><span class="comment"># 工作目录，默认是当前目录，运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span></span><br><span class="line">dir .</span><br><span class="line"><span class="comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span></span><br><span class="line">databases 1</span><br><span class="line"><span class="comment"># 设置redis能够使用的最大内存</span></span><br><span class="line">maxmemory 512mb</span><br><span class="line"><span class="comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span></span><br><span class="line">logfile <span class="string">&quot;redis.log&quot;</span></span><br><span class="line"></span><br><span class="line">redis-server redis.conf			<span class="comment"># 以配置文件启动</span></span><br><span class="line">redis-cli -u 123456 shutdown	<span class="comment"># 停止服务</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置开机自启</span></span><br><span class="line">vim /etc/systemd/system/redis.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加以下内容</span></span><br><span class="line"><span class="comment">#----------------</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/bin/redis-server /usr/<span class="built_in">local</span>/src/redis-6.2.6/redis.conf</span><br><span class="line">PrivateTmp=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"><span class="comment">#----------------</span></span><br><span class="line"></span><br><span class="line">systemctl daemon-reload			<span class="comment"># 重载系统服务</span></span><br><span class="line">systemctl start redis			<span class="comment"># 启动</span></span><br><span class="line">systemctl stop redis			<span class="comment"># 停止</span></span><br><span class="line">systemctl restart redis			<span class="comment"># 重启</span></span><br><span class="line">systemctl status redis			<span class="comment"># 查看状态</span></span><br><span class="line">systemctl <span class="built_in">enable</span> redis			<span class="comment"># 开机自启</span></span><br></pre></td></tr></table></figure>

<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>Redis自带了命令行客户端：redis-cli</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis-cli [options] [commonds]			</span><br><span class="line">option:</span><br><span class="line">	-h 127.0.0.1：	指定要连接的redis节点的IP地址，默认是127.0.0.1</span><br><span class="line">	-p 6379：		指定要连接的redis节点的端口，默认是6379</span><br><span class="line">	-a 123456：		指定redis的访问密码</span><br><span class="line">	</span><br><span class="line">ping							<span class="comment"># 与redis服务端做心跳测试</span></span><br><span class="line">	pong</span><br></pre></td></tr></table></figure>

<p>图形化桌面客户端</p>
<p>Redis的图形化桌面客户端：<a target="_blank" rel="noopener" href="https://github.com/uglide/RedisDesktopManager">https://github.com/uglide/RedisDesktopManager</a></p>
<p>windows安装包：<a target="_blank" rel="noopener" href="https://github.com/lework/RedisDesktopManager-Windows/releases">https://github.com/lework/RedisDesktopManager-Windows/releases</a></p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样：</p>
<table>
<thead>
<tr>
<th>Type</th>
<th></th>
<th>Class</th>
</tr>
</thead>
<tbody><tr>
<td>String</td>
<td>hello world</td>
<td>基本类型</td>
</tr>
<tr>
<td>Hash</td>
<td>{name:”jack”,age:21}</td>
<td>基本类型</td>
</tr>
<tr>
<td>List</td>
<td>{A-&gt;B-&gt;C-&gt;C}</td>
<td>基本类型</td>
</tr>
<tr>
<td>Set</td>
<td>{A,B,C}</td>
<td>基本类型</td>
</tr>
<tr>
<td>SortedSet</td>
<td>{A:1,B:2,C:3}</td>
<td>基本类型</td>
</tr>
<tr>
<td>GEO</td>
<td>{A:{120.3,30.5}}</td>
<td>特殊类型</td>
</tr>
<tr>
<td>BitMap</td>
<td>011011111001011001</td>
<td>特殊类型</td>
</tr>
<tr>
<td>HyperLog</td>
<td>011011101110011100</td>
<td>特殊类型</td>
</tr>
</tbody></table>
<p><code>灵用help，边用边查</code></p>
<h2 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>用处</th>
</tr>
</thead>
<tbody><tr>
<td>KEYS</td>
<td>查看符合模板的所有key</td>
</tr>
<tr>
<td>DEL</td>
<td>删除一个指定的key</td>
</tr>
<tr>
<td>EXISTS</td>
<td>判断key是否存在</td>
</tr>
<tr>
<td>EXPIRE</td>
<td>给一个key设置有效期，有效期到期时该key会被自动删除</td>
</tr>
<tr>
<td>TTL</td>
<td>查看一个KEY的剩余有效期</td>
</tr>
</tbody></table>
<h2 id="Key结构"><a href="#Key结构" class="headerlink" title="Key结构"></a>Key结构</h2><p>推荐使用：<code>项目名:业务:类型:id</code> </p>
<p>在Redis的桌面客户端，会以相同前缀作为层级结构，让数据看起来层次分明，关系清晰</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p>
<p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p>
<ul>
<li>string：普通字符串</li>
<li>int：整数类型，可以做自增、自减操作</li>
<li>float：浮点类型，可以做自增、自减操作, 必须指定步长</li>
</ul>
<p>不管是哪种格式，底层都是字节数组形式存储，只不过是<code>编码方式不同</code>。</p>
<p>字符串类型的最大空间不能超过512m.</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>用处</th>
</tr>
</thead>
<tbody><tr>
<td>SET</td>
<td>添加或者修改已经存在的一个String类型的键值对</td>
</tr>
<tr>
<td>GET</td>
<td>根据key获取String类型的value</td>
</tr>
<tr>
<td>MSET</td>
<td>批量添加多个String类型的键值对</td>
</tr>
<tr>
<td>MGET</td>
<td>根据多个key获取多个String类型的value</td>
</tr>
<tr>
<td>INCR</td>
<td>让一个整型的key自增1</td>
</tr>
<tr>
<td>INCRBY</td>
<td>让一个整型的key自增并指定步长</td>
</tr>
<tr>
<td>INCRBYFLOAT</td>
<td>让一个浮点类型的数字自增并指定步长</td>
</tr>
<tr>
<td>SETNX</td>
<td>添加一个String类型的键值对，前提是这个key不存在，否则不执行</td>
</tr>
<tr>
<td>SETEX</td>
<td>添加一个String类型的键值对，并且指定有效期</td>
</tr>
</tbody></table>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>Hash类型，也叫散列，其value是一个无序字典。</p>
<p>String结构是将对象序列化为JSON字符串后存储，当需要单独修改对象某个字段时很不方便。</p>
<p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>用处</th>
</tr>
</thead>
<tbody><tr>
<td>HSET key field value</td>
<td>添加或者修改hash类型key的field的值</td>
</tr>
<tr>
<td>HGET key field</td>
<td>获取一个hash类型key的field的值</td>
</tr>
<tr>
<td>HMSET</td>
<td>批量添加多个hash类型key的field的值</td>
</tr>
<tr>
<td>HMGET</td>
<td>批量获取多个hash类型key的field的值</td>
</tr>
<tr>
<td>HGETALL</td>
<td>获取一个hash类型的key中的所有的field和value</td>
</tr>
<tr>
<td>HKEYS</td>
<td>获取一个hash类型的key中的所有的field</td>
</tr>
<tr>
<td>HINCRBY</td>
<td>让一个hash类型key的字段值自增并指定步长</td>
</tr>
<tr>
<td>HSETNX</td>
<td>field不存在添加一个hash类型的key的field值，否则不执行</td>
</tr>
</tbody></table>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List可以看做是一个双向链表结构，既可以支持正向检索和也可以支持反向检索。</p>
<p>特征：</p>
<ul>
<li>有序</li>
<li>元素可以重复</li>
<li>插入和删除快</li>
<li>查询速度一般</li>
</ul>
<p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>用处</th>
</tr>
</thead>
<tbody><tr>
<td>LPUSH key element …</td>
<td>向列表左侧插入一个或多个元素</td>
</tr>
<tr>
<td>LPOP key</td>
<td>移除并返回列表左侧的第一个元素，没有则返回nil</td>
</tr>
<tr>
<td>RPUSH key element …</td>
<td>向列表右侧插入一个或多个元素</td>
</tr>
<tr>
<td>RPOP key</td>
<td>移除并返回列表右侧的第一个元素</td>
</tr>
<tr>
<td>LRANGE key star end</td>
<td>返回一段角标范围内的所有元素</td>
</tr>
<tr>
<td>BLPOP和BRPOP</td>
<td>阻塞等待指定时间，而不是直接返回nil</td>
</tr>
</tbody></table>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set结构可以看做是一个value为null的HashMap，特征：</p>
<ul>
<li>无序</li>
<li>元素不可重复</li>
<li>查找快</li>
<li>支持交集、并集、差集等功能</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>用处</th>
</tr>
</thead>
<tbody><tr>
<td>SADD key member …</td>
<td>向set中添加一个或多个元素</td>
</tr>
<tr>
<td>SREM key member …</td>
<td>移除set中的指定元素</td>
</tr>
<tr>
<td>SCARD key</td>
<td>返回set中元素的个数</td>
</tr>
<tr>
<td>SISMEMBER key member</td>
<td>判断一个元素是否存在于set中</td>
</tr>
<tr>
<td>SMEMBERS</td>
<td>获取set中的所有元素</td>
</tr>
<tr>
<td>SINTER key1 key2 …</td>
<td>求key1与key2的交集</td>
</tr>
<tr>
<td>SDIFF key1 key2 …</td>
<td>求key1与key2的差集</td>
</tr>
<tr>
<td>SUNION key1 key2 …</td>
<td>求key1和key2的并集</td>
</tr>
</tbody></table>
<h2 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h2><p>Redis的SortedSet是一个可排序的set集合，SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p>
<p>SortedSet具备下列特性：</p>
<ul>
<li>可排序</li>
<li>元素不重复</li>
<li>查询速度快</li>
</ul>
<p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>用处</th>
</tr>
</thead>
<tbody><tr>
<td>ZADD key score member</td>
<td>添加一个或多个元素到sorted set ，如果已经存在则更新其score值</td>
</tr>
<tr>
<td>ZREM key member</td>
<td>删除sorted set中的一个指定元素</td>
</tr>
<tr>
<td>ZSCORE key member</td>
<td>获取sorted set中的指定元素的score值</td>
</tr>
<tr>
<td>ZRANK key member</td>
<td>获取sorted set 中的指定元素的排名</td>
</tr>
<tr>
<td>ZCARD key</td>
<td>获取sorted set中的元素个数</td>
</tr>
<tr>
<td>ZCOUNT key min max</td>
<td>统计score值在给定范围内的所有元素的个数</td>
</tr>
<tr>
<td>ZINCRBY key increment member</td>
<td>让sorted set中的指定元素自增，步长为指定的increment值</td>
</tr>
<tr>
<td>ZRANGE key min max</td>
<td>按照score排序后，获取指定排名范围内的元素</td>
</tr>
<tr>
<td>ZRANGEBYSCORE key min max</td>
<td>按照score排序后，获取指定score范围内的元素</td>
</tr>
<tr>
<td>ZDIFF.ZINTER.ZUNION</td>
<td>求差集.交集.并集</td>
</tr>
</tbody></table>
<p><code>默认升序</code>，如果要降序则在命令的Z后面添加<code>REV</code>，ZRANK KEY MEMBER</p>
<h2 id="语言客户端"><a href="#语言客户端" class="headerlink" title="语言客户端"></a>语言客户端</h2><p>Redis官网提供了各种语言的客户端：<a target="_blank" rel="noopener" href="https://redis.io/docs/clients/">https://redis.io/docs/clients/</a></p>
<p>使用Redis连接池，减少连接创建的时间</p>
<p>RedisConnectionFacotry：工厂设计模式是实际开发中非常常用的一种设计模式，使用工厂，去降低代的耦合。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shallowshades.github.io.git/2022/12/13/Redis/" data-id="clca7m48j000mxog06j9q9fng" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ginchat" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/12/13/ginchat/" class="article-date">
  <time datetime="2022-12-12T16:00:00.000Z" itemprop="datePublished">2022-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/12/13/ginchat/">ginchat</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h3 id="gin"><a href="#gin" class="headerlink" title="gin"></a>gin</h3><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><h3 id="gorm"><a href="#gorm" class="headerlink" title="gorm"></a>gorm</h3><h3 id="swaggo"><a href="#swaggo" class="headerlink" title="swaggo"></a>swaggo</h3><p>生成API文档</p>
<h3 id="jwt"><a href="#jwt" class="headerlink" title="jwt"></a>jwt</h3><p>gin框架的中间件,提供身份验证</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shallowshades.github.io.git/2022/12/13/ginchat/" data-id="clca7m48l000sxog04shhhiwj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/go/" rel="tag">go</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-go" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/12/13/go/" class="article-date">
  <time datetime="2022-12-12T16:00:00.000Z" itemprop="datePublished">2022-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/12/13/go/">Go</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sodu vim /etc/profile </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将下面添加到profile中</span></span><br><span class="line">export GOROOT=&quot;/usr/local/go&quot;</span><br><span class="line">export GOPATH=$HOME/go</span><br><span class="line">export GOBIN=$GOROOT/bin</span><br><span class="line">export PATH=$PATH:$GOBIN</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新加载</span></span><br><span class="line">source /etc/profile</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检测</span></span><br><span class="line">go version</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改代理</span></span><br><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启Modules管理模式</span></span><br><span class="line">go env -w GO111MODULE=on</span><br></pre></td></tr></table></figure>

<h2 id="go-mod"><a href="#go-mod" class="headerlink" title="go mod"></a>go mod</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>go mod init</td>
<td>生成 go.mod 文件</td>
</tr>
<tr>
<td>go mod download</td>
<td>下载 go.mod 文件中指明的所有依赖</td>
</tr>
<tr>
<td>go mod tidy</td>
<td>整理现有的依赖</td>
</tr>
<tr>
<td>go mod graph</td>
<td>查看现有的依赖结构</td>
</tr>
<tr>
<td>go mod edit</td>
<td>编辑 go.mod 文件</td>
</tr>
<tr>
<td>go mod vendor</td>
<td>导出项目所有的依赖到vendor目录</td>
</tr>
<tr>
<td>go mod verify</td>
<td>校验一个模块是否被篡改过</td>
</tr>
<tr>
<td>go mod why</td>
<td>查看为什么需要依赖某模块</td>
</tr>
<tr>
<td>go mod -m [-json] all</td>
<td>显示详细的依赖关系</td>
</tr>
</tbody></table>
<p>导入本地包方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在go.mod文件中添加</span></span><br><span class="line">require <span class="keyword">package</span> v0<span class="number">.0</span><span class="number">.0</span>		<span class="comment">//导入的包名	版本号</span></span><br><span class="line">replace <span class="keyword">package</span> =&gt; path		<span class="comment">//路径</span></span><br></pre></td></tr></table></figure>

<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p><img src="D:\blog\hexo\source_posts\go.assets\defer.png" alt="defer执行时机"></p>
<p><code>defer注册要延迟执行的函数时该函数所有的参数都需要确定其值</code></p>
<h2 id="select-and-channel"><a href="#select-and-channel" class="headerlink" title="select and channel"></a>select and channel</h2><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><table>
<thead>
<tr>
<th>内置函数</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>close</td>
<td>主要用来关闭channel</td>
</tr>
<tr>
<td>len</td>
<td>用来求长度，比如string、array、slice、map、channel</td>
</tr>
<tr>
<td>new</td>
<td>用来分配内存，主要用来分配值类型，比如int、struct。返回的是指针</td>
</tr>
<tr>
<td>make</td>
<td>用来分配内存，主要用来分配引用类型，比如chan、map、slice</td>
</tr>
<tr>
<td>append</td>
<td>用来追加元素到数组、slice中</td>
</tr>
<tr>
<td>panic和recover</td>
<td>用来做错误处理</td>
</tr>
</tbody></table>
<h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><p><code>是一种抽象的类型,是一种合约</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> usb <span class="keyword">interface</span> &#123;</span><br><span class="line">	read()</span><br><span class="line">	write()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> computer <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c computer)</span> <span class="title">read</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;c.name: %v\t&quot;</span>, c.name)</span><br><span class="line">	fmt.Println(<span class="string">&quot;read...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c computer)</span> <span class="title">write</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;c.name: %v\t&quot;</span>, c.name)</span><br><span class="line">	fmt.Println(<span class="string">&quot;write...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//interface</span></span><br><span class="line">    <span class="keyword">var</span> u usb</span><br><span class="line"></span><br><span class="line">    u = &amp;computer&#123;name: <span class="string">&quot;lenveno&quot;</span>&#125;</span><br><span class="line">    u.read()</span><br><span class="line">    u.write()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>必须实现接口声明的所有的函数的类型才可以通过接口调用，否则编译报错</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> OpenClose <span class="keyword">interface</span> &#123;</span><br><span class="line">	open()</span><br><span class="line">	<span class="built_in">close</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Door <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Door)</span> <span class="title">open</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;open the door...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//必须实现接口的所有函数声明</span></span><br><span class="line">	<span class="keyword">var</span> oc OpenClose</span><br><span class="line">	oc = &amp;Door&#123;&#125; <span class="comment">//未实现close	compile error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>值接收者和指针接收者</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> usb <span class="keyword">interface</span> &#123;</span><br><span class="line">	read()</span><br><span class="line">	write()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> computer <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c computer)</span> <span class="title">read</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;c.name: %v\t&quot;</span>, c.name)</span><br><span class="line">	fmt.Println(<span class="string">&quot;read...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c computer)</span> <span class="title">write</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;c.name: %v\t&quot;</span>, c.name)</span><br><span class="line">	fmt.Println(<span class="string">&quot;write...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mobile <span class="keyword">struct</span> &#123;</span><br><span class="line">	model <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *mobile)</span> <span class="title">read</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;m.model: %v\t&quot;</span>, m.model)</span><br><span class="line">	fmt.Println(<span class="string">&quot;read...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *mobile)</span> <span class="title">write</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;m.model: %v\t&quot;</span>, m.model)</span><br><span class="line">	fmt.Println(<span class="string">&quot;write...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pet <span class="keyword">interface</span> &#123;</span><br><span class="line">	eat(<span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *dog)</span> <span class="title">eat</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;[dog]%s is eating %s\n&quot;</span>, d.name, name)</span><br><span class="line">	d.name = <span class="string">&quot;white&quot;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;eat well&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> u usb</span><br><span class="line"></span><br><span class="line">    <span class="comment">//computer 采用值接受，可以接受值或者指针</span></span><br><span class="line">    u = &amp;computer&#123;name: <span class="string">&quot;lenveno&quot;</span>&#125;</span><br><span class="line">    u.read()</span><br><span class="line">    u.write()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//mobile 采用指针接受，只能接受指针</span></span><br><span class="line">    u = &amp;mobile&#123;model: <span class="string">&quot;5G&quot;</span>&#125;</span><br><span class="line">    u.read()</span><br><span class="line">    u.write()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> p Pet</span><br><span class="line">    p = &amp;dog&#123;<span class="string">&quot;black&quot;</span>&#125; </span><br><span class="line"></span><br><span class="line">    p.eat(<span class="string">&quot;chicken&quot;</span>) <span class="comment">//不使用指针接受的情况，即使接口接受的是指针，函数也无法修改其内部值</span></span><br><span class="line">    fmt.Println(p)</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>一个类型可以实现多个接口</code></p>
<p><code>多个类型可以实现同一个接口</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> usb <span class="keyword">interface</span> &#123;</span><br><span class="line">	read()</span><br><span class="line">	write()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> player <span class="keyword">interface</span> &#123;</span><br><span class="line">	playMusic()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> video <span class="keyword">interface</span> &#123;</span><br><span class="line">	playVideo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> computer <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c computer)</span> <span class="title">read</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;c.name: %v\t&quot;</span>, c.name)</span><br><span class="line">	fmt.Println(<span class="string">&quot;read...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c computer)</span> <span class="title">write</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;c.name: %v\t&quot;</span>, c.name)</span><br><span class="line">	fmt.Println(<span class="string">&quot;write...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c computer)</span> <span class="title">playMusic</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;c.name: %v\t&quot;</span>, c.name)</span><br><span class="line">	fmt.Println(<span class="string">&quot;play music...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c computer)</span> <span class="title">playVideo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;c.name: %v\t&quot;</span>, c.name)</span><br><span class="line">	fmt.Println(<span class="string">&quot;play video...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pet <span class="keyword">interface</span> &#123;</span><br><span class="line">	eat(<span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *dog)</span> <span class="title">eat</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;[dog]%s is eating %s\n&quot;</span>, d.name, name)</span><br><span class="line">	d.name = <span class="string">&quot;white&quot;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;eat well&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cat)</span> <span class="title">eat</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;[cat]%s is eating %s\n&quot;</span>, c.name, name)</span><br><span class="line">	c.name = <span class="string">&quot;white&quot;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;eat well&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//一个类型可以实现多个接口</span></span><br><span class="line">    <span class="keyword">var</span> p player</span><br><span class="line">    <span class="keyword">var</span> v video</span><br><span class="line"></span><br><span class="line">    c := &amp;computer&#123;<span class="string">&quot;XiaoMi&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    p = c</span><br><span class="line">    p.playMusic()</span><br><span class="line"></span><br><span class="line">    v = c</span><br><span class="line">    v.playVideo()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//一个接口可以被多个类型实现</span></span><br><span class="line">    <span class="keyword">var</span> pet Pet</span><br><span class="line"></span><br><span class="line">    dog := &amp;dog&#123;<span class="string">&quot;black&quot;</span>&#125;</span><br><span class="line">    cat := &amp;cat&#123;<span class="string">&quot;kitty&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    pet = dog</span><br><span class="line">    pet.eat(<span class="string">&quot;bone&quot;</span>)</span><br><span class="line"></span><br><span class="line">    pet = cat</span><br><span class="line">    pet.eat(<span class="string">&quot;fish&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>接口可以嵌套</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Flyer <span class="keyword">interface</span> &#123;</span><br><span class="line">	fly()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Swimmer <span class="keyword">interface</span> &#123;</span><br><span class="line">	swim()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FlyFish <span class="keyword">interface</span> &#123;</span><br><span class="line">	Flyer</span><br><span class="line">	Swimmer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Fish <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Fish)</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;fly...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Fish)</span> <span class="title">swim</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;swim...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> ff FlyFish</span><br><span class="line">	ff = &amp;Fish&#123;&#125;</span><br><span class="line">	ff.fly()</span><br><span class="line">	ff.swim()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><blockquote>
<p>在main或其他函数中开协程，主程序结束了，协程还继续执行吗?</p>
</blockquote>
<p>main函数中的协程，如果main结束了，协程也会结束，mian函数结束意味着程序结束了吧</p>
<p> 其他函数里的协程，函数结束了，只要main没结束，协程就会执行。</p>
<h2 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h2><h3 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h3><p>map不是并发安全的，sync.Map并发安全</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Store</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m sync.Map</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//存</span></span><br><span class="line">	m.Store(<span class="string">&quot;Cloud&quot;</span>, <span class="string">&quot;Zack&quot;</span>)</span><br><span class="line">	<span class="comment">//取</span></span><br><span class="line">	value, ok := m.Load(<span class="string">&quot;Cloud&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;value: %v, ok: %v\n&quot;</span>, value, ok)</span><br><span class="line"></span><br><span class="line">	value, ok = m.Load(<span class="string">&quot;Alice&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;value: %v, ok: %v\n&quot;</span>, value, ok)</span><br><span class="line">	<span class="comment">//删</span></span><br><span class="line">	m.Delete(<span class="string">&quot;Cloud&quot;</span>)</span><br><span class="line"></span><br><span class="line">	value, ok = m.Load(<span class="string">&quot;Cloud&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;value: %v, ok: %v\n&quot;</span>, value, ok)</span><br><span class="line"></span><br><span class="line">	m.Store(<span class="string">&quot;Cloud&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">	m.Store(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">	m.Store(<span class="string">&quot;Tifa&quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">	m.Store(<span class="string">&quot;Barret&quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line">	<span class="comment">//遍历</span></span><br><span class="line">	m.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value any)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;k: &quot;</span>, key, <span class="string">&quot;v :&quot;</span>, value)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//load and delete 加载一个值，存在则删除</span></span><br><span class="line">	value, ok = m.LoadAndDelete(<span class="string">&quot;Cloud&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;value: %v, ok: %v\n&quot;</span>, value, ok)</span><br><span class="line"></span><br><span class="line">	m.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value any)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;k: &quot;</span>, key, <span class="string">&quot;v :&quot;</span>, value)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// load or store 如果存在就load，不存在就store</span></span><br><span class="line">	actual, loaded := m.LoadOrStore(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;5&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;actual : &quot;</span>, actual, <span class="string">&quot; loaded : &quot;</span>, loaded)</span><br><span class="line"></span><br><span class="line">	value, ok = m.Load(<span class="string">&quot;Alice&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;value: %v, ok: %v\n&quot;</span>, value, ok)</span><br><span class="line"></span><br><span class="line">	actual, loaded = m.LoadOrStore(<span class="string">&quot;Zack&quot;</span>, <span class="string">&quot;7&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;actual : &quot;</span>, actual, <span class="string">&quot; loaded : &quot;</span>, loaded)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>内存既可以分配到堆中，也可以分配到栈中。</p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>内存管理主要包括两个动作：分配与释放。逃逸分析就是服务于内存分配的，而内存的释放由GC负责。</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>在Go语言中，<strong>栈的内存是由编译器自动进行分配和释放的</strong>，栈区往往存储着函数参数、局部变量和调用函数帧，<strong>它们随着函数的创建而分配，随着函数的退出而销毁</strong>。</p>
<p>Go应用程序运行时，每个 goroutine 都维护着一个自己的栈区，这个栈区只能自己使用不能被其他 goroutine 使用。栈是调用栈（call stack）的简称。<strong>一个栈通常又包含了许多栈帧（stack frame），它描述的是函数之间的调用关系</strong></p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p><strong>与栈不同的是，堆区的内存一般由编译器和工程师自己共同进行管理分配，交给 Runtime GC 来释放。在堆上分配时，必须找到一块足够大的内存来存放新的变量数据。后续释放时，垃圾回收器扫描堆空间寻找不再被使用的对象。</strong></p>
<p><strong>用GO语言开发过程中，要考虑的内存管理只是针对堆内存而言的。</strong></p>
<p>程序在运行期间可以主动从堆上申请内存，这些内存通过Go的内存分配器分配，并由垃圾收集器回收。</p>
<h3 id="堆和栈的对比"><a href="#堆和栈的对比" class="headerlink" title="堆和栈的对比"></a>堆和栈的对比</h3><p><strong>加锁</strong></p>
<ul>
<li>  <strong>栈不需要加锁</strong>：每个goroutine都独享自己的栈空间，这就意味着栈上的内存操作是不需要加锁的。</li>
<li>  <strong>堆有时需要加锁</strong>：堆上的内存，有时需要加锁防止多线程冲突</li>
</ul>
<blockquote>
<p>  为什么堆上的内存有时需要加锁？而不是一直需要加锁呢？</p>
</blockquote>
<p>因为Go的内存分配策略学习了TCMalloc的线程缓存思想，他为每个处理器分配了一个mcache，注意：从mcache分配内存也是无锁的。</p>
<p>TCmalloc全称Thread-Caching Malloc，即线程缓存的malloc，实现了高效的多线程内存管理，用于替代系统的内存分配相关的函数（malloc、free，new，new[]等）。用于优化C++写的多线程应用。用途：让MySQL在高并发下内存占用更加稳定。</p>
<p><strong>性能</strong></p>
<ul>
<li>  <strong>栈内存管理 性能好</strong>：栈上的内存，它的分配与释放非常高效的。简单地说，它只需要两个CPU指令：一个是分配入栈，另外一个是栈内释放。只需要借助于栈相关寄存器即可完成。</li>
<li>  <strong>堆内存管理 性能差</strong>：对于程序堆上的内存回收，还需要有标记清除阶段，例如Go采用的三色标记法。</li>
</ul>
<h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><ul>
<li>  <strong>栈缓存性能更好</strong></li>
<li>  <strong>堆缓存性能较差</strong></li>
</ul>
<p>原因是：栈内存能更好地利用CPU的缓存策略，因为栈空间相较于堆来说是更连续的。</p>
<h2 id="变量逃逸分析"><a href="#变量逃逸分析" class="headerlink" title="变量逃逸分析"></a>变量逃逸分析</h2><p><strong>相比于把内存分配到堆中，分配到栈中优势更明显。</strong></p>
<p><strong>Go编译器会尽可能将变量分配到到栈上。</strong></p>
<p><strong>但是，在函数返回后无法证明变量未被引用，则该变量将被分配到堆上，该变量不随函数栈的回收而回收。以此避免悬挂指针（dangling pointer）的问题。</strong></p>
<p>另外，如果局部变量占用内存非常大，也会将其分配在堆上。</p>
<blockquote>
<p>  Go是如何确定内存是分配到栈上还是堆上的呢？</p>
</blockquote>
<p>答案：<code>逃逸分析</code>。</p>
<p><strong>编译器通过逃逸分析技术去选择堆或者栈，逃逸分析的基本思想如下：检查变量的生命周期是否是完全可知的，如果通过检查，则在栈上分配。否则，就是所谓的逃逸，必须在堆上进行分配。</strong></p>
<h3 id="逃逸原则"><a href="#逃逸原则" class="headerlink" title="逃逸原则"></a>逃逸原则</h3><p>Go语言虽然没有明确说明逃逸分析原则，但是有以下几点准则，是可以参考的。</p>
<ul>
<li>  Go的逃逸分析是在编译期完成的：编译期无法确定的参数类型<strong>必定</strong>放到堆中；</li>
<li>  如果变量在函数外部存在引用，则<strong>必定</strong>放在堆中；</li>
<li>  如果变量占用内存较大时，则<strong>优先</strong>放到堆中；</li>
<li>  如果变量在函数外部没有引用，则<strong>优先</strong>放到栈中；</li>
</ul>
<h3 id="逃逸分析命令"><a href="#逃逸分析命令" class="headerlink" title="逃逸分析命令"></a>逃逸分析命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -gcflags <span class="string">&#x27;-m -m -l&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-参数是interface类型"><a href="#1-参数是interface类型" class="headerlink" title="1.参数是interface类型"></a>1.参数是interface类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">666</span></span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原因分析</strong></p>
<p>因为Println(a …interface{})的参数是<code>interface&#123;&#125;</code>类型，编译期无法确定其具体的参数类型，所以内存分配到堆中。</p>
<h3 id="2-变量在函数外部有引用"><a href="#2-变量在函数外部有引用" class="headerlink" title="2. 变量在函数外部有引用"></a>2. 变量在函数外部有引用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> *<span class="title">int</span></span> &#123;</span><br><span class="line">	a := <span class="number">10</span></span><br><span class="line">	<span class="keyword">return</span> &amp;a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_ = test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原因分析</strong></p>
<p>变量a在函数外部存在引用。</p>
<p><strong>当函数执行完毕，对应的栈帧就被销毁，但是引用已经被返回到函数之外。如果这时外部通过引用地址取值，虽然地址还在，但是这块内存已经被释放回收了，这就是非法内存。</strong></p>
<p>为了避免上述非法内存的情况，在这种情况下变量的内存分配必须分配到堆上。</p>
<h3 id="3-变量内存占用较大"><a href="#3-变量内存占用较大" class="headerlink" title="3. 变量内存占用较大"></a>3. 变量内存占用较大</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10000</span>, <span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">   		a[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原因分析</strong></p>
<p>定义了一个容量为10000的int类型切片，发生了逃逸，内存分配到了堆上（heap）。</p>
<p>将切片的容量和长度修改为1，再次查看逃逸分析的结果，没有发生逃逸，内存默认分类到了栈上。</p>
<p>所以，当变量占用内存较大时，会发生逃逸分析，将内存分配到堆上。</p>
<h3 id="4-变量大小不确定时"><a href="#4-变量大小不确定时" class="headerlink" title="4. 变量大小不确定时"></a>4. 变量大小不确定时</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    l := <span class="number">1</span></span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="keyword">int</span>, l, l)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; l; i++ &#123;</span><br><span class="line">    	a[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原因分析</strong></p>
<p>发生了逃逸，分配到了heap堆中。</p>
<p><strong>虽然在代码段中给变量 l 赋值了1，但是编译期间只能识别到初始化int类型切片时，传入的长度和容量是变量l，编译期并不能确定变量l的值，所以发生了逃逸，会把内存分配到堆中。</strong></p>
<blockquote>
<p>尽量写出分配在栈上的代码。因为堆上的变量变少后，可以减轻内存分配的开销，减小GC的压力，提高程序的运行速度。</p>
</blockquote>
<p>在不断的需求变化，业务变化中求得==平衡==</p>
<p><strong>有些场景下我们不应该传递结构体指针，而应该直接传递结构体。</strong></p>
<p>虽然直接传递结构体需要值拷贝，但是这是在栈上完成的操作，开销远比变量逃逸后动态地在堆上分配内存少的多。</p>
<p>当然这种做法不是绝对的，要根据场景去分析：</p>
<ul>
<li>  <strong>如果结构体较大，传递结构体指针更合适，因为指针类型相比值类型能节省大量的内存空间</strong></li>
<li>  <strong>如果结构体较小，传递结构体更适合，因为在栈上分配内存，可以有效减少GC压力</strong></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>要根据实际场景考虑，如何将内存尽量分配到栈中，减少GC的压力，提高性能。</p>
<p>找到应用开发效率、程序运行效率、对机器的压力及负载的平衡点。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shallowshades.github.io.git/2022/12/13/go/" data-id="clca7m48r001axog0699o8tqj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/" rel="tag">golang</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-git" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/09/08/git/" class="article-date">
  <time datetime="2022-09-08T09:15:46.000Z" itemprop="datePublished">2022-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/08/git/">git</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><h2 id="git基础设置"><a href="#git基础设置" class="headerlink" title="git基础设置"></a>git基础设置</h2><p>git config –global user.name “&lt;用户名&gt;”</p>
<p>git config –global user.email “&lt;电子邮件&gt;” </p>
<p>git config –global color.ui auto 以彩色显示</p>
<p>git config –global core.editor “vim” 将编辑器配置成vim</p>
<p>export GIT_EDITOR=vim 在环境变量中将编辑器配置成vim</p>
<p>git config –global alias.co checkout 为Git命令设定别名 把「checkout」缩略为「co」，然后就使用「co」来执行命令</p>
<h2 id="git基础命令"><a href="#git基础命令" class="headerlink" title="git基础命令"></a>git基础命令</h2><p>git init 初始化一个空的或者已经存在的数据库</p>
<p>git add <fileName> 往索引树中添加一个文件</p>
<p>git commit -m <comment> 提交到数据库</p>
<p>git commit –amend 修改最后一次提交的注释</p>
<p>git log 查看日志</p>
<p>git status 查看工作树和索引的状态</p>
<p>git branch 查看分支</p>
<p>git branch <branchName> 新建一个分支</p>
<p>git switch/checkout <branchName> 选择一个分支</p>
<p>git checkout -b <branchName> 新建一个分支并选择该分支</p>
<p>git merge <branchName> 合并一个分支(以当前分支为基础合并分支节点)</p>
<p>git rebase <branchName> 合并一个分支(以目标分支为基础，将本分支与目标分支不同的节点复制到目标分支，变成一条直线)</p>
<h2 id="git高级命令"><a href="#git高级命令" class="headerlink" title="git高级命令"></a>git高级命令</h2><p>git checkout &lt;hashCode、 HEAD或分支当前位置及其相对位置&gt;  分离HEAD （hashCode不能作为相对位置的基值）</p>
<p>^ 向上相对移动一个位置</p>
<p>~<num> 向上相对移动num个位置，默认为1</p>
<p>git reset &lt;同上&gt; 回退到目标状态，只能在本地操作，是真的回退</p>
<p>git revert &lt;同上&gt; 回退到目标状态，可以在远端操作，不是真的回退，是再生成一个新的状态来代替目标状态</p>
<h2 id="自由修改提交树"><a href="#自由修改提交树" class="headerlink" title="自由修改提交树"></a>自由修改提交树</h2><p>git cherry-pick &lt;hashCode、hashCode、… &gt; 将选择的状态挂在当前HEAD或者分支名所指向的节点下（若是当前HEAD或者分支名并非指向叶子节点，则已当前HEAD指向的节点创建新分支，按选择顺序）</p>
<p>git rebase -i(interaction) &lt;同上，但是是范围选择&gt;  可以对选择范围内的状态进行删除、重排、合并、修改注释等操作</p>
<h2 id="git远程"><a href="#git远程" class="headerlink" title="git远程"></a>git远程</h2><p>git remote  add <repoName>  <url> 添加一个远程仓库，repoName就是对这个仓库取得本地名字，后续通过该名字指定该仓库</p>
<p>git clone <url> 克隆一个git数据库到本地</p>
<p>git push <repoName> <branch> 将本地推到远端，但是如果在远端有本地未同步的状态时，将无法推送</p>
<p>git fetch <repoName> <branch> 将远端的数据拉取到本地</p>
<p>git pull <repoName> <branch> 将远端的数据拉取到本地并合并 （pull = fetch + merge）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shallowshades.github.io.git/2022/09/08/git/" data-id="clca7m48m000vxog06gmrgi8k" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/" rel="tag">git</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-设计模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/07/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2022-07-16T03:06:15.000Z" itemprop="datePublished">2022-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/07/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>松耦合设计思想 </p>
<p>面向对象设计原则</p>
<p>重构技法改善设计 </p>
<p>GOF 核心设计模式</p>
<p><strong>什么是设计模式</strong> </p>
<p>​    “每一个模式描述了一个在我们周围不断重复发生的问题， 以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动”。 ——Christopher Alexander</p>
<h2 id="设计模式概括"><a href="#设计模式概括" class="headerlink" title="设计模式概括"></a>设计模式概括</h2><h3 id="从面向对象谈起"><a href="#从面向对象谈起" class="headerlink" title="从面向对象谈起"></a>从面向对象谈起</h3><p><strong>底层思维</strong>：向下，如何把握机器底层 从微观理解对象构造 </p>
<p>• 语言构造 </p>
<p>• 编译转换</p>
<p>• 内存模型 </p>
<p>• 运行时机制</p>
<p><strong>抽象思维</strong>：向上，如何将我们的周围 世界抽象为程序代码 </p>
<p>• 面向对象 </p>
<p>• 组件封装 </p>
<p>• 设计模式 </p>
<p>• 架构模式</p>
<h3 id="深入理解面向对象"><a href="#深入理解面向对象" class="headerlink" title="深入理解面向对象"></a>深入理解面向对象</h3><p>向下：深入理解三大面向对象机制 </p>
<p>• 封装，隐藏内部实现 </p>
<p>• 继承，复用现有代码 </p>
<p>• 多态，改写对象行为</p>
<p>向上：深刻把握面向对象机制所带来的抽象意义，理解如何使用 这些机制来表达现实世界，掌握什么是“好的面向对象设计”</p>
<h3 id="软件设计复杂的根本原因：变化"><a href="#软件设计复杂的根本原因：变化" class="headerlink" title="软件设计复杂的根本原因：变化"></a>软件设计复杂的根本原因：<strong>变化</strong></h3><p>• 客户需求的变化 </p>
<p>• 技术平台的变化 </p>
<p>• 开发团队的变化 </p>
<p>• 市场环境的变化</p>
<h3 id="如何解决复杂性？"><a href="#如何解决复杂性？" class="headerlink" title="如何解决复杂性？"></a>如何解决复杂性？</h3><p><strong>分解</strong> </p>
<p>• 人们面对复杂性有一个常见的做法：即分而治之，将大问题分解为多个小问题，将复杂问题分解为多个简单问题。 </p>
<p><strong>抽象</strong> </p>
<p>• 更高层次来讲，人们处理复杂性有一个通用的技术，即抽象。 由于不能掌握全部的复杂对象，我们选择忽视它的非本质细节， 而去处理泛化和理想化了的对象模型。</p>
<h3 id="软件设计的目标：复用"><a href="#软件设计的目标：复用" class="headerlink" title="软件设计的目标：复用"></a>软件设计的目标：复用</h3><p><strong>复用 复用 复用</strong></p>
<h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><h3 id="面向对象设计：抵御变化"><a href="#面向对象设计：抵御变化" class="headerlink" title="面向对象设计：抵御变化"></a>面向对象设计：抵御变化</h3><p>变化是复用的天敌！ 面向对象设计最大的优势在于： <strong>抵御变化</strong>！</p>
<h3 id="重新认识面向对象"><a href="#重新认识面向对象" class="headerlink" title="重新认识面向对象"></a>重新认识面向对象</h3><p>理解隔离变化 </p>
<p>• 从宏观层面来看，面向对象的构建方式更能适应软件的变化， 能将变化所带来的影响减为最小 </p>
<p>各司其职 </p>
<p>• 从微观层面来看，面向对象的方式更强调各个类的“责任” </p>
<p>• 由于需求变化导致的新增类型不应该影响原来类型的实现—— 是所谓各负其责 </p>
<p>对象是什么？ </p>
<p>• 从语言实现层面来看，对象封装了代码和数据。 </p>
<p>• 从规格层面讲，对象是一系列可被使用的公共接口。 </p>
<p>• 从概念层面讲，对象是某种拥有责任的抽象。</p>
<h3 id="依赖倒转原则（DIP）"><a href="#依赖倒转原则（DIP）" class="headerlink" title="依赖倒转原则（DIP）"></a>依赖倒转原则（DIP）</h3><p>• 高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于 抽象(稳定) 。 </p>
<p>• 抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于 抽象(稳定)。</p>
<h3 id="开放封闭原则（OCP）"><a href="#开放封闭原则（OCP）" class="headerlink" title="开放封闭原则（OCP）"></a>开放封闭原则（OCP）</h3><p>• 对扩展开放，对更改封闭。 </p>
<p>• 类模块应该是可扩展的，但是不可修改。</p>
<h3 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h3><p>• 一个类应该仅有一个引起它变化的原因。 </p>
<p>• 变化的方向隐含着类的责任。</p>
<h3 id="Liskov-替换原则（LSP）"><a href="#Liskov-替换原则（LSP）" class="headerlink" title="Liskov 替换原则（LSP）"></a>Liskov 替换原则（LSP）</h3><p>• 子类必须能够替换它们的基类(IS-A)。 </p>
<p>• 继承表达类型抽象。</p>
<h3 id="接口隔离原则（ISP）"><a href="#接口隔离原则（ISP）" class="headerlink" title="接口隔离原则（ISP）"></a>接口隔离原则（ISP）</h3><p>• 不应该强迫客户程序依赖它们不用的方法。 </p>
<p>• 接口应该小而完备。</p>
<p>（该private就private，用不到的不用开放）</p>
<h3 id="优先使用对象组合，而不是类继承"><a href="#优先使用对象组合，而不是类继承" class="headerlink" title="优先使用对象组合，而不是类继承"></a>优先使用对象组合，而不是类继承</h3><p>• 类继承通常为“白箱复用”，对象组合通常为“黑箱复用”。 </p>
<p>• 继承在某种程度上破坏了封装性，子类父类耦合度高。 </p>
<p>• 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。</p>
<h3 id="封装变化点"><a href="#封装变化点" class="headerlink" title="封装变化点"></a>封装变化点</h3><p>• 使用封装来创建对象之间的分界层，让设计者可以在分界层的 一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。</p>
<h3 id="针对接口编程，而不是针对实现编程"><a href="#针对接口编程，而不是针对实现编程" class="headerlink" title="针对接口编程，而不是针对实现编程"></a>针对接口编程，而不是针对实现编程</h3><p>• 不将变量类型声明为某个特定的具体类，而是声明为某个接口。 </p>
<p>• 客户程序无需获知对象的具体类型，只需要知道对象所具有的 接口。 </p>
<p>• 减少系统中各部分的依赖关系，从而实现“高内聚、松耦合” 的类型设计方案。</p>
<h3 id="面向接口设计：接口标准化"><a href="#面向接口设计：接口标准化" class="headerlink" title="面向接口设计：接口标准化"></a>面向接口设计：接口标准化</h3><h3 id="设计原则提升为设计经验"><a href="#设计原则提升为设计经验" class="headerlink" title="设计原则提升为设计经验"></a>设计原则提升为设计经验</h3><ol>
<li><p>设计习语 Design Idioms </p>
<p>  • Design Idioms 描述与特定编程语言相关的低层模式，技巧， 惯用法。 </p>
</li>
<li><p>设计模式 Design Patterns </p>
<p>  • Design Patterns主要描述的是“类与相互通信的对象之间的组 织关系，包括它们的角色、职责、协作方式等方面。 </p>
</li>
<li><p>架构模式 Architectural Patterns </p>
<p>  • Architectural Patterns描述系统中与基本结构组织关系密切的 高层模式，包括子系统划分，职责，以及如何组织它们之间关系的规则。</p>
</li>
</ol>
<h2 id="GOF-23-模式分类"><a href="#GOF-23-模式分类" class="headerlink" title="GOF-23 模式分类"></a>GOF-23 模式分类</h2><p>从<strong>目的</strong>来看： </p>
<p>• 创建型（Creational）模式：将对象的部分创建工作延迟到子类或者其他对象，从而应对需求变化为对象创建时具体类型实现引来的冲击。 </p>
<p>• 结构型（Structural）模式：通过类继承或者对象组合获得更灵活的结构，从而应对需求变化为对象的结构带来的冲击。 </p>
<p>• 行为型（Behavioral）模式：通过类继承或者对象组合来划分类与对象间的职责，从而应对需求变化为多个交互的对象带来的冲击。 </p>
<p>从<strong>范围</strong>来看： </p>
<p>• 类模式处理类与子类的静态关系。</p>
<p>• 对象模式处理对象间的动态关系。 </p>
<p>从<strong>封装变化</strong>角度对模式分类</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220717215938881.png" alt="image-20220717215938881"></p>
<h2 id="重构获得模式-Refactoring-to-Patterns"><a href="#重构获得模式-Refactoring-to-Patterns" class="headerlink" title="重构获得模式 Refactoring to Patterns"></a>重构获得模式 Refactoring to Patterns</h2><p>面向对象设计模式是“好的面向对象设计”，所谓“好的面向对 象设计”指是那些可以满足 “应对变化，提高复用”的设计 。 </p>
<p>现代软件设计的特征是“需求的频繁变化”。设计模式的要点是 “寻找变化点，然后在变化点处应用设计模式，从而来更好地应对 需求的变化”.“什么时候、什么地点应用设计模式”比“理解设 计模式结构本身”更为重要。 </p>
<p>设计模式的应用不宜先入为主，一上来就使用设计模式是对设计 模式的最大误用。没有一步到位的设计模式。敏捷软件开发实践提 倡的“Refactoring to Patterns”是目前普遍公认的最好的使用设 计模式的方法。</p>
<h2 id="重构关键技法"><a href="#重构关键技法" class="headerlink" title="重构关键技法"></a>重构关键技法</h2><p><strong>静态 -&gt; 动态</strong> </p>
<p><strong>早绑定  -&gt; 晚绑定</strong> </p>
<p><strong>继承  -&gt;  组合</strong> </p>
<p><strong>编译时依赖  -&gt; 运行时依赖</strong> </p>
<p><strong>紧耦合  -&gt;  松耦合</strong></p>
<h2 id="“组件协作”模式"><a href="#“组件协作”模式" class="headerlink" title="“组件协作”模式"></a>“组件协作”模式</h2><p>现代软件专业分工之后的第一个结果是“框架与应用程序的划分”，“组件协作”模式通过晚期绑定，来实现框架与应用程序之间的松耦合，是二者之间协作时常用的模式。 </p>
<p>典型模式 </p>
<p>• Template Method </p>
<p>• Observer / Event </p>
<p>• Strategy</p>
<h2 id="Template-Method"><a href="#Template-Method" class="headerlink" title="Template Method"></a>Template Method</h2><h3 id="动机（Motivation）"><a href="#动机（Motivation）" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h3><p>在软件构建过程中，对于某一项任务，它常常有稳定的整体操作 结构，但各个子步骤却有很多改变的需求，或者由于固有的原因 （比如框架与应用之间的关系）而无法和任务的整体结构同时实现。 </p>
<p>如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求？</p>
<p><strong>将变化的部分设为纯虚函数，在子类中实现</strong></p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220717220730182.png" alt="image-20220717220730182"></p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220717220746003.png" alt="image-20220717220746003"></p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220717220802247.png" alt="image-20220717220802247"></p>
<p><strong>C++实现晚绑定的方式是虚函数</strong></p>
<p><strong>C实现晚绑定的方式是函数指针</strong></p>
<h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p>定义一个操作中的算法的骨架 (稳定)，而将一些步骤延迟 (变化)到子类中。Template Method使得子类可以不改变 (复用)一个算法的结构即可重定义(override 重写)该算法的某些特定步骤。                 ——《设计模式》GoF</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220717221146483.png" alt="image-20220717221146483"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Template Method模式是一种非常基础性的设计模式，在面向对象系统中有着大量的应用。它用最简洁的机制（虚函数的多态性） 为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构。 </p>
<p>除了可以灵活应对子步骤的变化外，“<strong>不要调用我，让我来调用你</strong>”的反向控制结构是Template Method的典型应用。 </p>
<p>在具体实现方面，被Template Method调用的虚方法可以具有实现，也可以没有任何实现（抽象方法、纯虚方法），但一般推荐将它们设置为protected方法。</p>
<h2 id="Strategy-策略模式"><a href="#Strategy-策略模式" class="headerlink" title="Strategy 策略模式"></a>Strategy 策略模式</h2><h3 id="动机（Motivation）-1"><a href="#动机（Motivation）-1" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h3><p>在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂； 而且有时候支持不使用的算法也是一个性能负担。 </p>
<p>如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？</p>
<h3 id="模式定义-1"><a href="#模式定义-1" class="headerlink" title="模式定义"></a>模式定义</h3><p>定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序(稳定)而变化（扩展，子类化）。                                                                                                                                                         ——《设计模式》GoF</p>
<h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220718212016095.png" alt="image-20220718212016095"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换。 </p>
<p>Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需要Strategy模式。 </p>
<p>如果Strategy对象没有实例变量，那么各个上下文可以共享同一个 Strategy对象，从而节省对象开销。</p>
<h2 id="Observer-观察者模式（Event）"><a href="#Observer-观察者模式（Event）" class="headerlink" title="Observer 观察者模式（Event）"></a>Observer 观察者模式（Event）</h2><h3 id="动机（Motivation）-2"><a href="#动机（Motivation）-2" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h3><p>在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系” ——一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密， 将使软件不能很好地抵御变化。 </p>
<p>使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。</p>
<h3 id="模式定义-2"><a href="#模式定义-2" class="headerlink" title="模式定义"></a>模式定义</h3><p>定义对象间的一种一对多（变化）的依赖关系，以便当一个对象(Subject)的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。                                                                                                                                                                                     ——《设计模式》GoF</p>
<h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220718221003403.png" alt="image-20220718221003403"></p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><strong>我们订阅你（加入圈子），你有动态就发送到（圈子），我们按照各自的方式收到通知</strong></p>
<p>使用面向对象的抽象，Observer模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖关系达致松耦合。 </p>
<p>目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。 </p>
<p>观察者自己决定是否需要订阅通知，目标对象对此一无所知。 </p>
<p>Observer模式是基于事件的UI框架中非常常用的设计模式，也是MVC模式的一个重要组成部分。</p>
<h2 id="“单一职责”模式"><a href="#“单一职责”模式" class="headerlink" title="“单一职责”模式"></a>“单一职责”模式</h2><p>在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码， 这时候的关键是划清责任。 </p>
<p>典型模式 </p>
<p>• Decorator </p>
<p>• Bridge</p>
<h2 id="Decorator-装饰模式"><a href="#Decorator-装饰模式" class="headerlink" title="Decorator 装饰模式"></a>Decorator 装饰模式</h2><h3 id="动机（Motivation）-3"><a href="#动机（Motivation）-3" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h3><p>在某些情况下我们可能会“过度地使用继承来扩展对象的功能” ， 由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性； 并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展 功能的组合）会导致更多子类的膨胀。 </p>
<p>如何使“对象功能的扩展”能够根据需要来动态地实现？同时避 免“扩展功能的增多”带来的子类膨胀问题？从而使得任何“功能 扩展变化”所导致的影响将为最低？</p>
<h3 id="模式定义-3"><a href="#模式定义-3" class="headerlink" title="模式定义"></a>模式定义</h3><p>动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（<strong>消除重复代码 &amp; 减少子类个数</strong>）。                                                                                                                                                                     ——《设计模式》GoF</p>
<h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><p><img src="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.assets/image-20220721214326119.png" alt="image-20220721214326119"></p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><strong>继承和组合同时使用</strong></p>
<p>通过采用组合而非继承的手法， Decorator模式实现了在运行时 动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的“灵活性差”和“多子类衍生问题” 。 </p>
<p>Decorator类在接口上表现为is-a Component的继承关系，即 Decorator类继承了Component类所具有的接口。但在实现上又表现为has-a Component的组合关系，即Decorator类又使用了 另外一个Component类。 </p>
<p>Decorator模式的目的并非解决“多子类衍生的多继承”问题， Decorator模式应用的要点在于解决“主体类在多个方向上的扩展功能”——是为“装饰”的含义。</p>
<h2 id="Bridge-桥模式"><a href="#Bridge-桥模式" class="headerlink" title="Bridge 桥模式"></a>Bridge 桥模式</h2><h3 id="动机（Motivation）-4"><a href="#动机（Motivation）-4" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h3><p>由于某些类型的固有的实现逻辑，使得它们具有两个变化的维度， 乃至多个纬度的变化。 </p>
<p>如何应对这种“多维度的变化”？如何利用面向对象技术来使得 类型可以轻松地沿着两个乃至多个方向变化，而不引入额外的复杂度？</p>
<h3 id="模式定义-4"><a href="#模式定义-4" class="headerlink" title="模式定义"></a>模式定义</h3><p>将抽象部分(业务功能)与实现部分(平台实现)分离，使它们都可以独立地变化。                                                     ——《设计模式》GoF</p>
<h3 id="结构（Structure）"><a href="#结构（Structure）" class="headerlink" title="结构（Structure）"></a>结构（Structure）</h3><p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220722013246305.png" alt="image-20220722013246305"></p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固 有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自纬度的变化，即“子类化”它们。 </p>
<p>Bridge模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则（即一个类只有一个变化的原因），复用性比较差。 Bridge模式是比多继承方案更好的解决方法。 </p>
<p>Bridge模式的应用一般在“两个非常强的变化维度”，有时一个 类也有多于两个的变化维度，这时可以使用Bridge的扩展模式。</p>
<h2 id="“对象创建”模式"><a href="#“对象创建”模式" class="headerlink" title="“对象创建”模式"></a>“对象创建”模式</h2><p>通过“对象创建” 模式绕开new，来避免对象创建（new）过程 中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。 </p>
<p>典型模式 </p>
<p>•Factory Method </p>
<p>•Abstract Factory </p>
<p>•Prototype </p>
<p>•Builder</p>
<h2 id="Factory-Method工厂方法"><a href="#Factory-Method工厂方法" class="headerlink" title="Factory Method工厂方法"></a>Factory Method工厂方法</h2><h3 id="动机（Motivation）-5"><a href="#动机（Motivation）-5" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h3><p>在软件系统中，经常面临着创建对象的工作；由于需求的变化， 需要创建的对象的具体类型经常变化。 </p>
<p>如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一 种“封装机制”来避免客户程序和这种“具体对象创建工作”的紧耦合？</p>
<h3 id="模式定义-5"><a href="#模式定义-5" class="headerlink" title="模式定义"></a>模式定义</h3><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。 Factory Method使得一个类的实例化延迟（目的：解耦， 手段：虚函数）到子类。                                                                                                                                                                             ——《设计模式》GoF</p>
<h3 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h3><p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220722021206221.png" alt="image-20220722021206221"></p>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>Factory Method模式用于隔离类对象的使用sw者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导致软件的脆弱。 </p>
<p>Factory Method模式通过面向对象的手法，将所要创建的具体对象工作延迟到子类，从而实现一种扩展（而非更改）的策略，较好地解决了这种紧耦合关系。 </p>
<p>Factory Method模式解决“单个对象”的需求变化。缺点在于要求创建方法/参数相同。</p>
<h2 id="Abstract-Factory-抽象工厂"><a href="#Abstract-Factory-抽象工厂" class="headerlink" title="Abstract Factory 抽象工厂"></a>Abstract Factory 抽象工厂</h2><h3 id="动机（Motivation）-6"><a href="#动机（Motivation）-6" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h3><p>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时，由于需求的变化，往往存在更多系列对象的创建工作。 </p>
<p>如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一 种“封装机制”来避免客户程序和这种“多系列具体对象创建工作” 的紧耦合?</p>
<h3 id="模式定义-6"><a href="#模式定义-6" class="headerlink" title="模式定义"></a>模式定义</h3><p>提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们具体的类。                            ——《设计模式》GoF</p>
<h3 id="结构（Structure）-1"><a href="#结构（Structure）-1" class="headerlink" title="结构（Structure）"></a>结构（Structure）</h3><p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220722213156905.png" alt="image-20220722213156905"></p>
<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>如果没有应对“多系列对象构建”的需求变化，则没有必要使用 Abstract Factory模式，这时候使用简单的工厂完全可以。 </p>
<p>“系列对象”指的是在某一特定系列下的对象之间有相互依赖、 或作用的关系。不同系列的对象之间不能相互依赖。 </p>
<p>Abstract Factory模式主要在于应对“新系列”的需求变动。其缺点在于难以应对“新对象”的需求变动。</p>
<h2 id="Prototype-模式"><a href="#Prototype-模式" class="headerlink" title="Prototype 模式"></a>Prototype 模式</h2><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>在软件系统中，经常面临着“某些结构复杂的对象”的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是它们却拥有比较稳定一致的接口。</p>
<p>如何应对这种变化？如何向“客户程序（使用这些对象的程序）”隔离出“这些易变对象”，从而使得“依赖这些易变对象的客户端程序”不随着需求改变而改变？</p>
<h3 id="模式定义-7"><a href="#模式定义-7" class="headerlink" title="模式定义"></a>模式定义</h3><p>使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。                                        ——《设计模式》 GoF</p>
<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>Prototype模式同样用于隔离类对象的使用者和具体类型(易变类)之间的耦合关系，它同样要求这些“易变类拥有“稳定的接口”。</p>
<p>Prototype模式对于“如何创建易变类的实体对象”采用“原型克隆”的方法来做，它使得我们可以非常灵活地动态创建‘拥有某些稳定接口”的新对象——所需工作仅仅是注册一个新类的对象(即原型)，然后在任何需要的地方Clone。</p>
<p>Prototype模式中的Clone方法可以利用某些框架中的序列化来实现深拷贝。</p>
<h2 id="Builder-构建器"><a href="#Builder-构建器" class="headerlink" title="Builder 构建器"></a>Builder 构建器</h2><h3 id="动机（Motivation）-7"><a href="#动机（Motivation）-7" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h3><p>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p>
<p>如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂 对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？</p>
<h3 id="模式定义-8"><a href="#模式定义-8" class="headerlink" title="模式定义"></a>模式定义</h3><p>将一个复杂对象的构建与其表示相分离，使得同样的构建过程(稳定)可以创建不同的表示(变化)。                     ——《设计模式》GoF</p>
<h3 id="结构（Structure）-2"><a href="#结构（Structure）-2" class="headerlink" title="结构（Structure）"></a>结构（Structure）</h3><p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220725211536921.png" alt="image-20220725211536921"></p>
<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>Builder 模式主要用于“分步骤构建一个复杂的对象”。在这其中 “分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化。 </p>
<p>变化点在哪里，封装哪里—— Builder模式主要在于应对“复杂对 象各个部分”的频繁需求变动。其缺点在于难以应对“分步骤构建 算法”的需求变动。 </p>
<p>在Builder模式中，要注意不同语言中构造器内调用虚函数的差别 （C++ vs. C#) </p>
<h2 id="“对象性能”-模式"><a href="#“对象性能”-模式" class="headerlink" title="“对象性能” 模式"></a>“对象性能” 模式</h2><p>面向对象很好地解决了”抽象” 的问题，但是必不可免地要付出一定的代价。 对于通常情况来讲,面向对象的成本大都可以忽略不计。但是某些情况,面向对象所带来的成本必须谨慎处理。</p>
<p>典型模式:</p>
<p>·Singleton<br>·Flyweight</p>
<h2 id="Singleton单件模式"><a href="#Singleton单件模式" class="headerlink" title="Singleton单件模式"></a>Singleton单件模式</h2><h3 id="动机-Motivation"><a href="#动机-Motivation" class="headerlink" title="动机( Motivation )"></a>动机( Motivation )</h3><p>在软件系统中,经常有这样一些特殊的类，必须保证它们在系统中只存在一个实例,才能确保它们的逻辑正确性、以及良好的效率。<br>如何绕过常规的构造器,提供-一种机制来保证一个类只有一个实例?</p>
<p>这应该是类设计者的责任,而不是使用者的责任。</p>
<h3 id="模式定义-9"><a href="#模式定义-9" class="headerlink" title="模式定义"></a>模式定义</h3><p>保证一个类仅有一个实例 ,并提供一个该实例的全局访问点。                                                                            一《设计模式》GoF .</p>
<h3 id="结构-5"><a href="#结构-5" class="headerlink" title="结构"></a>结构</h3><p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220725212029932.png" alt="image-20220725212029932"></p>
<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><p>Singleton模式中的实例构造器可以设置为protected以允许子类派生。</p>
<p>Singleton模式一般不要支持拷贝构造函数和Clone接口, 因为这有可能导致多个对象实例,与Singleton模式的初衷违背。</p>
<p>如何实现多线程环境下安全的Singleton ?注意对双检查锁的正确实现。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shallowshades.github.io.git/2022/07/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" data-id="clca7m494002qxog0d5fh8wee" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DesignMode/" rel="tag">DesignMode</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-C++进阶" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/06/22/C++%E8%BF%9B%E9%98%B6/" class="article-date">
  <time datetime="2022-06-22T03:41:05.000Z" itemprop="datePublished">2022-06-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/06/22/C++%E8%BF%9B%E9%98%B6/">C++杂项</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="重载-重写-覆盖-隐藏"><a href="#重载-重写-覆盖-隐藏" class="headerlink" title="重载 重写(覆盖) 隐藏"></a>重载 重写(覆盖) 隐藏</h2><ol>
<li><p>重载(overload):<br> 定义：<br> 同一个类中的函数具有相同名称，但参数列表不同（参数个数，参数类型），这样同名不同参数的函数之间，互为重载函数，属于编译时多态。<br> 特点：<br> ①同一个类中（相同作用域）<br> ②函数名称必须相同<br> ③函数参数必须不同<br> ④函数返回类型可同可不同，不重要</p>
</li>
<li><p>重写(override):<br>定义：<br>也称为覆盖，是指子类重新定义父类中有相同函数名，参数列表，返回类型的虚函数。子类对象使用这个方法时，将调用子类中的定义，父类中的定义如同被“屏蔽”了，属于运行时多态。<br>特点：<br>①函数名、参数列表、返回类型必须完全与被重写方法的相同；<br>②访问权限不能比父类中被重写的方法的访问权限更低<br>③重写函数和被重写函数都是virtual函数（派生类函数可以不带virtual关键字）<br>④声明为final的方法不能被重写。<br>⑤声明为static的方法不能被重写，但是能够被再次声明。<br>⑥构造函数不能被重写</p>
</li>
<li><p>隐藏(hide):<br>定义：<br>也叫重定义，指的是派生类类型的对象、指针、引用访问基类和派生类都有的同名函数时，访问的是派生类的函数，即隐藏了基类的同名函数。</p>
</li>
</ol>
<p>隐藏规则：<br>（1）如果派生类的函数与基类的函数同名，参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏。<br>（2）如果派生类的函数与基类的函数同名，参数相同，但基类函数没有virtual关键字时，基类的函数被隐藏。</p>
<p>二. 重载、重写、隐藏区别</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>作用域</th>
<th>有无virtual</th>
<th>函数名</th>
<th>参数列表</th>
<th>返回类型</th>
</tr>
</thead>
<tbody><tr>
<td>重载</td>
<td>相同</td>
<td>可有可无</td>
<td>相同</td>
<td>不同</td>
<td>可同可不同</td>
</tr>
<tr>
<td>重写</td>
<td>不同</td>
<td>有</td>
<td>相同</td>
<td>相同</td>
<td>相同(协变)</td>
</tr>
<tr>
<td>隐藏</td>
<td>不同</td>
<td>可有可无</td>
<td>相同</td>
<td>可同可不同</td>
<td>可同可不同</td>
</tr>
</tbody></table>
<p>注：重写在协变时返回类型可不同。<br>协变：C++中只要原来的返回类型是指向基类的指针或引用，新的返回类型是指向派生类的指针或引用，重写可以改变返回类型。这样的类型称为协变返回类型(Covariant returns type)。</p>
<h2 id="协变-抗变-不变"><a href="#协变-抗变-不变" class="headerlink" title="协变 抗变 不变"></a>协变 抗变 不变</h2><p>协变、抗变英文分别是  Covariance 、Contravariance</p>
<p>这是数学和物理学术语，在OO领域中也有应用。<br>“共变”、“逆变”是一种译法，另外一种译法是“协变”、“抗变”。特别在OO领域，基本上都是用后面这组。此外还有“不变（Nonvariance）”。 </p>
<p>在OO中，协变是指按照继承链正向改变，抗变是指逆向改变。</p>
<p>在C++标准的虚函数中，返回值协变，参数不变。</p>
<h2 id="函数入栈"><a href="#函数入栈" class="headerlink" title="函数入栈"></a>函数入栈</h2><p>将函数参数压入栈中，可以发现参数的压栈顺序是从右向左的。<br>将call指令后面一条指令的地址压入栈中，函数返回后会跳转到该地址。将调用方栈底地址压入栈中。<br>将EBX，ESI，EDI压入栈中，这也就是常说的函数中断前的“保护现场”，EBX，ESI，EDI分别为基址寄存器，源变址寄存器，目的变址寄存器。<br>通过call指令跳转到函数的起始地址，将函数内部的变量去堆栈上开辟空间，执行函数功能。<br>函数执行完成后，取出保存在栈中的寄存器数值并将寄存器的值也恢复到了函数调用之前，并取回函数返回地址，函数返回。</p>
<h2 id="C和C-中static的区别"><a href="#C和C-中static的区别" class="headerlink" title="C和C++中static的区别"></a>C和C++中static的区别</h2><p>static在C语言中的作用（C++通用）<br>1、修饰变量<br> a、修饰全局变量（全局变量与静态全局变量的对比）</p>
<p>修饰全局变量：作用域仅限于变量被定义的文件中，其他文件即使用extern声明也无法直接使用此变量。（可以间接访问，即通过本文件的非static函数返回static变量的值，类似于C++类中的private变量外界没有权限访问，但是可以通过public函数返回private变量的值）。<br>对比：全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同，且都只初始化一次，但静态全局变量对其他文件不可见，全局变量是可见的。<br>总结：把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。<br>b、修饰局部变量</p>
<p>修饰局部变量：在函数内定义的局部变量被修饰，可以延长变生命周期，但是作用域不变，只初始化一次。<br>对比：普通局部变量定义后，出了作用域就会被释放，静态局部变量生命周期到程序结束才结束。<br>总结：把局部变量改变为静态变量后是改变了它的存储方式，让静态局部变量出了作用域依然存在，到程序结束，生命周期才结束。<br>2、修饰函数<br>和全局变量一样，函数的定义和声明默认情况下是extern的，但静态函数只是在声明它的文件当中可见，不能被其他文件所用。</p>
<p>三、static在C++中的作用<br>C+ +重用了这个关键字，并赋予它与前面不同的含义：表示属于一个类而不是属于此类的任何特定对象的变量和函数。</p>
<p>1、静态数据成员.<br>静态数据成员是属于整个类的，而不是属于某个对象。即不管实例多少个对象，它们都公用一个静态数据成员（如：使用静态数据成员统计类已经实例化了多少对象）。</p>
<p>在c++中，普通数据成员在构造函数的函数体或初始化表中初始化；常量数据成员(const int a )必须在构造函数的初始化表中初始化（const对象或引用只能初始化但是不能赋值。构造函数的函数体内只能做赋值而不是初始化）；而静态数据成员(static int b )则必须在类外初始化（int 类名::b=100），这是因为静态数据成员不属于任何一个对象，而是属于整个类的。</p>
<p>2、静态成员函数<br>静态成员函数是属于整个类的，而不是属于某个对象。静态成员函数可以被该类的所有对象直接访问；静态成员函数本身只能访问静态成员，不可以访问非静态成员。</p>
<p>常见面试题–<strong>为什么static变量值只初始化一次</strong><br>对于所有的对象（不仅仅是静态对象），初始化都只有一次，而由于静态变量具有“记忆”功能，初始化后，一直都没有被销毁，都会保存在内存区域中，所以不会再次初始化。存放在静态区的变量的生命周期一般比较长，它与整个程序“同生死、共存亡”，所以它只需初始化一次。而auto变量，即自动变量，由于它存放在栈区，一旦函数调用结束，就会立刻被销毁。</p>
<h2 id="c与c-中的extern"><a href="#c与c-中的extern" class="headerlink" title="c与c++中的extern"></a>c与c++中的extern</h2><p><strong>声明不分配内存，能在代码中出现多次；定义分配内存，在代码中只出现一次</strong></p>
<p>在c和c++中，extern被用来修改标识符（变量和函数）的链接属性。被extern修饰的声明，表示该修饰符对其他模块（源文件）可见，同时也表示该修饰符可以从其他模块找到定义。这种对标识符链接属性的修饰是双向的，既可以被其它模块看见，也可以看见其它模块。</p>
<p>在默认情况下，函数外的标识符的链接属性是extern的。如果想让对标识符进行隔离，即不能在模块间链接标识符，则需要在标识符的前面添加static。</p>
<p>对于变量的声明，比函数要复杂一些。没有显式extern的变量声明时，变量进行默认的初始化（分配内存），<strong>变量的定义和声明是同时完成的；</strong>当进行显式的extern声明时，变量不能默认初始化。</p>
<p>extern除了改变标识符的链接属性之外，在c++中，还有特殊的用法。<strong>extern “C” 能够使c++中使用c语言的代码</strong>。</p>
<p>总结一下：</p>
<ol>
<li> 声明不分配内存，能重复；定义分配内存，不能重复</li>
<li> extern改变了标识符链接属性</li>
<li> 变量声明没有显式extern时，自动初始化</li>
<li> c++中的extern “C”</li>
</ol>
<h2 id="C-对象构造和析构的顺序"><a href="#C-对象构造和析构的顺序" class="headerlink" title="C++对象构造和析构的顺序"></a>C++对象构造和析构的顺序</h2><p><strong>先构造后析构</strong></p>
<p><strong>构造子类对象时，先父类，再构造子类，析构则相反</strong>(<strong>父类名称构造子类对象时，父类析构函数要设置为虚函数，不然会内存泄露(子类未析构)</strong>)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">base</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base default ctor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">base</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base default dtor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">drived</span> :</span> <span class="keyword">public</span> base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">drived</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;drived default ctor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">drived</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;drived default dtor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        drived d1;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        base* b1 = <span class="keyword">new</span> drived;</span><br><span class="line">        <span class="keyword">delete</span> b1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;end...\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">base <span class="keyword">default</span> ctor</span><br><span class="line">drived <span class="keyword">default</span> ctor</span><br><span class="line">drived <span class="keyword">default</span> dtor</span><br><span class="line">base <span class="keyword">default</span> dtor</span><br><span class="line">---------------------</span><br><span class="line">base <span class="keyword">default</span> ctor</span><br><span class="line">drived <span class="keyword">default</span> ctor</span><br><span class="line">drived <span class="keyword">default</span> dtor</span><br><span class="line">base <span class="keyword">default</span> dtor</span><br><span class="line">end...</span><br></pre></td></tr></table></figure>

<h2 id="面向对象设计的六大原则"><a href="#面向对象设计的六大原则" class="headerlink" title="面向对象设计的六大原则"></a>面向对象设计的六大原则</h2><p>1、<strong>开闭原则</strong>（Open Close Principle）</p>
<p>Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.</p>
<p>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。<br>符合开闭原则的开发过程应该是使用抽象、接口来搭建程序框架，使用具体的实现来完成扩展细节</p>
<p>通过接口的方式实现了程序框架，通过类来实现对既定功能的实现和扩展，完美的解决了需要反复添加修改和冗余错误的问题。</p>
<p>2、<strong>里氏代换原则</strong>（Liskov Substitution Principle）</p>
<p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<p>3、<strong>依赖倒转原则</strong>（Dependence Inversion Principle）</p>
<p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p>
<p>4、<strong>接口隔离原则</strong>（Interface Segregation Principle）</p>
<p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p>
<p>5、<strong>迪米特法则</strong>，又称最少知道原则（Demeter Principle）</p>
<p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<p>6、<strong>合成复用原则</strong>（Composite Reuse Principle）</p>
<p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p>
<h2 id="super"><a href="#super" class="headerlink" title="__super"></a>__super</h2><p>类内使用，指向父类的指针visual C++</p>
<h2 id="四种强制转换"><a href="#四种强制转换" class="headerlink" title="四种强制转换"></a>四种强制转换</h2><p>1、<strong>static_cast</strong>（静态类型转换）<br>a:用于类层次结构中基类和派生类指针或引用的转换：</p>
<p>上行转换：派生类转换为基类 ；（安全的）</p>
<p>下行转换：基类转换为派生类；（是不安全的，没有动态类型检查）</p>
<p>b:用于基本数据类型之间的转换</p>
<p>c:空类型指针与其他类型的指针进行转换<br>这种使用场景容易出错，因为有可能出现未知的转换结果，要保证转换的正确性就必须保证转换后所得的类型就是指针原先的类型</p>
<p>2、<strong>dynamic_cast</strong>（动态类型转换）<br>用于类层次间上行和下行的转换，在进行下行转换时会进行动态类型转换是安全的。</p>
<p>除非特殊情况，一般使用动态转换，要不然将上下文变得更确定，更安全而使用静态</p>
<p>3、 <strong>const_cast</strong>（常量转换）<br>用来修饰类型的const属性：把常量指针或常量引用转换为非常量指针或非常量引用，并仍然指向原来的对象；把非常量指针或非常量引用转换为常量指针或常量引用，并仍然指向原来的对象；</p>
<p>注意：不能直接对非常量指针或非常量引用的变量使用const_cast操作符。</p>
<p>4、<strong>reinterpret_cast</strong>（重新解释转换）<br>万能转换，可以把指针转换成常量（万物皆可转）。</p>
<h2 id="四种智能指针"><a href="#四种智能指针" class="headerlink" title="四种智能指针"></a>四种智能指针</h2><ol>
<li><p> C++中的智能指针有4种，分别为：<strong>shared_ptr、unique_ptr、weak_ptr、auto_ptr</strong>，其中auto_ptr被C++11弃用。</p>
</li>
<li><p>使用智能指针的原因</p>
<p>   申请的空间（即new出来的空间），在使用结束时，需要delete掉，否则会形成内存碎片。在程序运行期间，new出来的对象，在析构函数中delete掉，但是这种方法不能解决所有问题，因为有时候new发生在某个全局函数里面，该方法会给程序员造成精神负担。<strong>此时，智能指针就派上了用场。</strong>使用智能指针可以很大程度上避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源。所以，智能指针的作用原理就是在函数结束时自动释放内存空间，避免了手动释放内存空间。</p>
</li>
<li><p>四种指针分别解决的问题以及各自特性如下：</p>
<p> （1）<strong>auto_ptr</strong>（C++98的方案，<strong>C++11已经弃用</strong>）</p>
<p>   采用<strong>所有权模式</strong>。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;I reigned loney as a cloud.&quot;</span>))</span></span>;</span><br><span class="line">auto_ptr&lt;string&gt; p2;</span><br><span class="line">p2=p1; <span class="comment">//auto_ptr不会报错</span></span><br></pre></td></tr></table></figure>

<p>   此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题。</p>
<p> （2）<strong>unique_ptr</strong>（替换auto_ptr，<strong>独占式</strong>）</p>
<p> unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露，例如，以  new创建对象后因为发生异常而忘记调用delete时的情形特别有用。</p>
<p>   采用所有权模式，和上面例子一样。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;hello, world&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"><span class="comment">//unique_ptr&lt;string&gt; p2 = p1;//编译时报错，</span></span><br><span class="line"><span class="comment">//p2 = p1;// 因为拷贝构造和拷贝赋值函数已经被删除</span></span><br><span class="line">cout &lt;&lt; *p1 &lt;&lt; endl; </span><br><span class="line"><span class="comment">//cout &lt;&lt; *p2 &lt;&lt; endl;</span></span><br></pre></td></tr></table></figure>

<p> 编译器认为P2=P1非法，避免了p1不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。 另外unique_ptr还有更聪明的地方：<strong>当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做</strong>；<strong>如果源 unique_ptr 将存在一段时间，编译器将禁止这么做</strong>，比如：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;hello, world&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"><span class="comment">//p2 = p1;							//#1编译器不允许</span></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">p3 = unique_ptr&lt;string&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;joker&quot;</span>)); <span class="comment">//编译器允许</span></span><br></pre></td></tr></table></figure>

<p> 其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。</p>
<p>   <strong>注意：</strong>如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。例如：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;hello, world&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">p2 = <span class="built_in">move</span>(p1);</span><br><span class="line"><span class="keyword">if</span> (p1) &#123;</span><br><span class="line">    cout &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1 is nullptr\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p1 = unique_ptr&lt;string&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;joker&quot;</span>));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*p1 = &quot;</span> &lt;&lt; *p1 &lt;&lt; <span class="string">&quot;\n*p2 = &quot;</span> &lt;&lt; *p2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p> （3）<strong>shared_ptr</strong>（<strong>共享</strong>）</p>
<p> shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。</p>
<p>  shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。</p>
<p> <strong>成员函数：</strong></p>
<p> <strong>use_count</strong>  返回引用计数的个数</p>
<p> <strong>unique</strong>  返回是否是独占所有权( use_count 为 1)</p>
<p> <strong>swap</strong>  交换两个 shared_ptr 对象(即交换所拥有的对象)</p>
<p> <strong>reset</strong>  放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</p>
<p> <strong>get</strong>  返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的</p>
<p> （4）<strong>weak_ptr</strong></p>
<p> weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象。进行该对象的内存管理的是那个强引用的 shared_ptr。weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来<strong>协助 shared_ptr 工作</strong>，它<strong>只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造</strong>, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用，那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种<strong>弱引用</strong>，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;B&gt; pb_;</span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;A delete\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;A&gt; pa_;</span><br><span class="line">    ~<span class="built_in">B</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;B delete\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">pb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">pa</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    pb-&gt;pa_ = pa;</span><br><span class="line">    pa-&gt;pb_ = pb;</span><br><span class="line">    cout&lt;&lt;pb.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;pa.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，把类A里面的shared_ptr pb_; 改为weak_ptr pb; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。</p>
<p>   <strong>注意</strong>：不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(),不能这样访问，pa-&gt;pb*-&gt;print(); 英文pb*是一个weak_ptr，应该先把它转化为shared_ptr，如：shared_ptr p = pa-&gt;pb_.lock(); p-&gt;print(); </p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//shared_ptr&lt;B&gt; pb_;</span></span><br><span class="line">	weak_ptr&lt;B&gt; pb_;</span><br><span class="line">	~<span class="built_in">A</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;A delete\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//shared_ptr&lt;A&gt; pa_;</span></span><br><span class="line">	weak_ptr&lt;A&gt; pa_;</span><br><span class="line">	~<span class="built_in">B</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;B delete\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;B print()\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">shared_ptr&lt;B&gt; <span class="title">pb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">	<span class="function">shared_ptr&lt;A&gt; <span class="title">pa</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">	pb-&gt;pa_ = pa;</span><br><span class="line">	pa-&gt;pb_ = pb;</span><br><span class="line">	cout &lt;&lt; pb.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; pa.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	pa.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; pb.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; pa.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; pb-&gt;pa_.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">smartPoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//auto_ptr C++11已弃用</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">auto_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;hello,world&quot;</span>))</span></span>;</span><br><span class="line">		auto_ptr&lt;string&gt; p2 = p1;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; *p1 &lt;&lt; endl; //使用p1会报错</span></span><br><span class="line">		cout &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//unique独占</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">unique_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;hello, world&quot;</span>))</span></span>;</span><br><span class="line">		<span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">		<span class="comment">//unique_ptr&lt;string&gt; p2 = p1;//编译时报错，</span></span><br><span class="line">		<span class="comment">//p2 = p1;// 因为拷贝构造和拷贝赋值函数已经被删除</span></span><br><span class="line">		cout &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; *p2 &lt;&lt; endl;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//unique可窃取临时对象</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">unique_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;hello, world&quot;</span>))</span></span>;</span><br><span class="line">		<span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">		<span class="comment">//p2 = p1;							//编译器不允许</span></span><br><span class="line">		<span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">		p3 = unique_ptr&lt;string&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;joker&quot;</span>)); <span class="comment">//编译器允许</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用move函数可以</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;move-----------\n&quot;</span>;</span><br><span class="line">		<span class="function">unique_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;hello, world&quot;</span>))</span></span>;</span><br><span class="line">		<span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">		p2 = <span class="built_in">move</span>(p1);</span><br><span class="line">		<span class="keyword">if</span> (p1) &#123;</span><br><span class="line">			cout &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;p1 is nullptr\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		p1 = unique_ptr&lt;string&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;joker&quot;</span>));</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;*p1 = &quot;</span> &lt;&lt; *p1 &lt;&lt; <span class="string">&quot;\n*p2 = &quot;</span> &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//共享</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;shared_ptr----------------\n&quot;</span>;</span><br><span class="line">		<span class="function">shared_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;hello,world&quot;</span>))</span></span>;</span><br><span class="line">		shared_ptr&lt;string&gt; p2 = p1;</span><br><span class="line">		<span class="function">shared_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;joker&quot;</span>))</span></span>;</span><br><span class="line">		cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(shared_ptr&lt;string&gt;::element_type).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;*p1 = &quot;</span> &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;*p3 = &quot;</span> &lt;&lt; *p3 &lt;&lt; endl;</span><br><span class="line">		p1.<span class="built_in">swap</span>(p3);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;*p1 = &quot;</span> &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;*p3 = &quot;</span> &lt;&lt; *p3 &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		p3.<span class="built_in">reset</span>();</span><br><span class="line">		cout &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (p3 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;p3 reset\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; boolalpha &lt;&lt; p2.<span class="built_in">unique</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//weak_ptr</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;weak_ptr----------\n&quot;</span>;</span><br><span class="line">		<span class="built_in">fun</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//不能通过weak_ptr直接访问对象的方法</span></span><br><span class="line">		<span class="function">shared_ptr&lt;B&gt; <span class="title">pb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">		<span class="function">shared_ptr&lt;A&gt; <span class="title">pa</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">		pb-&gt;pa_ = pa;</span><br><span class="line">		pa-&gt;pb_ = pb;</span><br><span class="line">		<span class="comment">//pa-&gt;pb-&gt;print();//无法使用</span></span><br><span class="line">		shared_ptr&lt;B&gt; p = pa-&gt;pb_.<span class="built_in">lock</span>();</span><br><span class="line">		cout &lt;&lt; p.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">		p-&gt;<span class="built_in">print</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="物理CPU-物理CPU内核-逻辑处理器"><a href="#物理CPU-物理CPU内核-逻辑处理器" class="headerlink" title="物理CPU 物理CPU内核 逻辑处理器"></a>物理CPU 物理CPU内核 逻辑处理器</h2><p>1.说明<br>CPU(Central Processing Unit)是中央处理单元，<br>本文介绍物理CPU，物理CPU内核，逻辑CPU，<br>以及他们三者之间的关系，<br>一个物理CPU可以有1个或者多个物理内核，<br>一个物理内核可以作为1个或者2个逻辑CPU。</p>
<p>2.物理CPU<br>物理CPU就是计算机上实际安装的CPU，<br>物理CPU数就是主板上实际插入的CPU数量。<br>在Linux上查看/proc/cpuinfo，<br>其中的physical id就是每个物理CPU的id，<br>有几个不同的physical id就有几个物理CPU。</p>
<p>3.物理CPU内核<br>每颗物理CPU可以有1个或者多个物理内核，<br>通常每颗物理CPU的内核数都是固定的，<br>单核CPU就是有1个物理内核，<br>双核CPU就是有2个物理内核。<br>在Linux上查看/proc/cpuinfo，<br>其中的core id就是每颗物理CPU的物理内核id，<br>有几个不同的core id就有几个物理内核。<br>总的CPU物理内核数 = 物理CPU数 * 每颗物理CPU的内核数</p>
<p>4.逻辑CPU<br>操作系统可以使用逻辑CPU来模拟真实CPU。<br>在没有多核处理器的时候，<br>一个物理CPU只能有一个物理内核，<br>而现在有了<strong>多核技术</strong>，<br>一个物理CPU可以有多个物理内核，<br>可以把一个CPU当作多个CPU使用，<br>也就是所谓的逻辑CPU。<br>没有开启<strong>超线程</strong>时，逻辑CPU的个数就是总的CPU物理内核数。<br>然而开启超线程后，逻辑CPU的个数就是总的CPU物理内核数的两倍。<br>在Linux上查看/proc/cpuinfo，<br>其中的processor就是逻辑CPU，<br>有几个processor就有几个逻辑CPU。<br>总的逻辑CPU数 = 物理CPU个数 * 每颗物理CPU的核数 * 超线程数<br>总的逻辑CPU数 = 总的CPU物理内核数 * 超线程数</p>
<p>5.几核几线程<br>基于上面的基本概念，<br>理解一下常说的几核几线程。<br>如果计算机有一个物理CPU，<br>是双核的，支持超线程。<br>那么这台计算机就是双核四线程。<br>实际上几核几线程中的线程数就是逻辑CPU数。<br>对于两路四核超线程计算机，<br>两路指计算机有2个物理CPU，<br>每颗CPU中有4个物理内核，<br>CPU支持超线程，<br>就有242=16个逻辑CPU，<br>这就是通常所谓的16核计算机。</p>
<p><img src="C++%E6%9D%82%E9%A1%B9.assets/f42613dfc5c54d8a8787f0a8df22f185.png" alt="img"></p>
<p>左图：多个物理CPU，CPU通过总线进行通信，效率比较低。</p>
<p>右图：多核CPU，不同的核通过L2 cache进行通信，存储和外设通过总线与CPU通信</p>
<p>进程是程序的一次执行过程，是一个动态概念，是程序在执行过程中分配和管理资源的基本单位，</p>
<p>线程是CPU调度和分派的基本单位，它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>
<p><strong>联系：</strong>线程是进程的一部分，一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；</p>
<p>根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</p>
<p><strong>多时候是和线程打交道，一个程序是一整个进程，程序中可以有多个线程，用来并行进行不同的事情。</strong></p>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p><strong>根本</strong>区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</p>
<p>在<strong>开销</strong>方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p>
<p>所处<strong>环境</strong>：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</p>
<p><strong>内存分配</strong>方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。</p>
<p>包含<strong>关系</strong>：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p>
<p><strong>线程与进程的区别和联系? 线程是否具有相同的堆栈? dll是否有独立的堆栈?</strong></p>
<p>进程是死的，只是一些资源的集合，真正的程序执行都是线程来完成的，程序启动的时候操作系统就帮你创建了一个主线程。</p>
<p>每个线程有自己的堆栈。</p>
<p>动态链接库DLL中有没有独立的堆栈，这个问题不好回答。因为DLL中的代码是被某些线程所执行，只有线程拥有堆栈，如果DLL中的代码是EXE中的线程所调用，那么这个时候是不是说这个DLL没有自己独立的堆栈？如果DLL中的代码是由DLL自己创建的线程所执行，那么是不是说DLL有独立的堆栈？</p>
<p>以上讲的是堆栈，如果对于堆来说，每个DLL有自己的堆，所以如果是从DLL中动态分配的内存，最好是从DLL中删除，如果你从DLL中分配内存，然后在EXE中，或者另外一个DLL中删除，很有可能导致程序崩溃</p>
<h2 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h2><p>sizeof用法总结<br>sizeof有着许多的用法，而且很容易引起一些错误。下面根据sizeof后面的参数对sizeof的用法做个总结。</p>
<p>A．参数为数据类型或者为一般变量。例如sizeof(int),sizeof(long)等等。这种情况要注意的是不同系统系统或者不同编译器得到的结果可能是不同的。例如int类型在16位系统中占2个字节，在32位系统中占4个字节。</p>
<p>B．参数为数组或指针。下面举例说明</p>
<p>int a[50]; //sizeof(a)=4*50=200;sizeof(a)求数组所占的空间大小</p>
<p>int *a=new int[50];// sizeof(a)=4; a为一个指针，sizeof(a)是求指针的大小,在32位系统中，当然是占4个字节。<br>C．参数为结构或类。sizeof应用在类和结构的处理情况是相同的。</p>
<p>但有两点需要注意:</p>
<p>第一、结构或者类中的静态成员不对结构或者类的大小产生影响，因为静态变量的存储位置与结构或者类的实例地址无关。</p>
<p>第二、没有成员变量的结构或类的大小为1，因为必须保证结构或类的每一个实例在内存中都有唯一的地址。</p>
<p>第三、包含虚函数或纯虚函数的类的大小，在32位系统为4，类的内部有一个虚表指针，大小为4。在64位系统为8.</p>
<p>第四、在一个空类中，添加构造函数和析构函数，sizeof的结果还是1。调用构造函数和析构函数只需</p>
<h2 id="程序计数器PC"><a href="#程序计数器PC" class="headerlink" title="程序计数器PC"></a>程序计数器PC</h2><p>pc指向下一条指令的<strong>地址</strong></p>
<p>pc的长度取决于内存大小和指令长度 len = 内存/指令长度</p>
<h2 id="C-函数编译原理和成员函数的实现"><a href="#C-函数编译原理和成员函数的实现" class="headerlink" title="C++函数编译原理和成员函数的实现"></a>C++函数编译原理和成员函数的实现</h2><p><strong>编译器通过指针来访问成员变量，指针指向哪个对象就使用哪个对象的数据；</strong></p>
<p><strong>编译器通过指针的类型来访问成员函数，指针属于哪个类的类型就使用哪个类的函数</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MSVC</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">char</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">double</span> y, <span class="keyword">char</span> z)</span></span>;</span><br><span class="line"><span class="comment">//void func(int x);//无法重载仅按返回值区分的函数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">2.5</span>, <span class="string">&#x27;k&#x27;</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">2</span>, <span class="number">3.14</span>, <span class="string">&#x27;d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">	A a;</span><br><span class="line">	B b;</span><br><span class="line">	a.<span class="built_in">func</span>();</span><br><span class="line">	a.<span class="built_in">func</span>(<span class="number">1</span>);</span><br><span class="line">	b.<span class="built_in">func</span>();</span><br><span class="line">	b.<span class="built_in">func</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//&quot;int __cdecl func(void)&quot; (? func@@YAHXZ)</span></span><br><span class="line">	<span class="comment">//&quot;int __cdecl func(int)&quot; (? func@@YAHH@Z)</span></span><br><span class="line">	<span class="comment">//&quot;int __cdecl func(double,char)&quot; (? func@@YAHND@Z)</span></span><br><span class="line">	<span class="comment">//&quot;int __cdecl func(int,double,char)&quot; (? func@@YAHHND@Z)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//&quot;public: void __thiscall A::func(void)&quot; (? func@A@@QAEXXZ)</span></span><br><span class="line">	<span class="comment">//&quot;public: virtual void __thiscall A::func(int)&quot; (? func@A@@UAEXH@Z)</span></span><br><span class="line">	<span class="comment">//&quot;public: void __thiscall B::func(void)&quot; (? func@B@@QAEXXZ)</span></span><br><span class="line">	<span class="comment">//&quot;public: virtual void __thiscall B::func(int)&quot; (? func@B@@UAEXH@Z)</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h2><p>函数调用约定的几种类型有：__stdcall, __cdecl, __fastcall, __thiscall, __nakedcall, __pascal</p>
<p>下面介绍几种常见的函数调用约定（以MSVC编译器为例）：</p>
<p>（1） __cdecl调用约定</p>
<ol>
<li><p>参数从右向左传递，放在栈中</p>
</li>
<li><p>栈平衡由调用函数来执行</p>
</li>
<li><p>不定参数的函数可以使用</p>
</li>
</ol>
<p>（2）__stdcall调用约定</p>
<ol>
<li><p>参数从右向左传递，放在栈中</p>
</li>
<li><p>栈平衡操作由被调用函数执行</p>
</li>
<li><p>不定参数的函数无法使用</p>
</li>
</ol>
<p>（3）__fastcall调用约定</p>
<ol>
<li><p>最左边的两个不大于4字节的参数分别放在ecx和edx寄存器，其余参数仍然从右到左压入栈</p>
</li>
<li><p>被调用方平衡栈</p>
</li>
<li><p>不定参数无法使用</p>
</li>
</ol>
<p>4） __thiscall调用约定<br>thiscall仅仅用于c++成员函数。this指针存放于ecx寄存器中，参数从右到左压栈，被调用方平衡栈。thiscall不是关键词不能被程序员指定。</p>
<h2 id="C-三五法则"><a href="#C-三五法则" class="headerlink" title="C++三五法则"></a>C++三五法则</h2><p>当定义一个类时，显式或隐式地定义了此类型的对象在拷贝、赋值和销毁时做什么？</p>
<p>一个类通过定义三种特殊成员成员函数来控制这些操作：拷贝构造函数、拷贝赋值函数、析构函数。</p>
<p><strong>C++三法则</strong>：如果需要析构函数，则一定需要拷贝构造函数和拷贝赋值操作符。</p>
<p>如何理解这句话，通常，若一个类需要析构函数，则代表其合成的析构函数不足以释放类所拥有的资源，其中最典型的就是指针成员。</p>
<p>所以需要自己写析构函数来释放给指针所分配的内存来防止内存泄露。</p>
<p>那么为什么说“一定需要拷贝构造函数和赋值操作符”呢？</p>
<p>原因还是这样：类中出现了指针类型的成员。有指针类型的成员，必须防止浅拷贝问题，所以，一定需要拷贝构造函数和赋值操作符，这两个函数是防止浅拷贝问题所必须的。</p>
<p><strong>五法则</strong></p>
<p>在较新的 C++11 标准中，为了支持移动语义，又增加了移动构造函数和移动赋值运算符，这样共有五个特殊的成员函数，所以又称为“C++五法则”；</p>
<p>也就是说，“三法则”是针对较旧的 C++89 标准说的，“五法则”是针对较新的 C++11 标准说的；为了统一称呼，后来人们干把它叫做“C++ 三/五法则”；</p>
<p>与三之法则不同的是，不提供移动构造函数和移动赋值运算符通常不是错误，但会导致失去优化机会。</p>
<h2 id="析构函数设置为私有"><a href="#析构函数设置为私有" class="headerlink" title="析构函数设置为私有"></a>析构函数设置为私有</h2><p>1.创建私有析构函数不会导致编译器错误。</p>
<p>2.在栈上创建对象会导致编译错误，编译器知道析构不可访问</p>
<p>3.在堆上创建对象不会导致编译错误，编译器觉得程序员会自己搞定</p>
<p>4.<strong>new出的对象使用友元来释放</strong></p>
<h2 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h2><p>在调用函数的时候，会把实参传递给函数，有时候传给函数的是左值，有时候给的是右值，有时候还可能给的是 const 类型。在这些情况下，要求函数接收参数后，依然能保持这些类型，这时候就需要用转发了。看下面这个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">middle1</span><span class="params">(F f, T1 t1, T2 t2)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">f</span>(t1, t2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个模板函数有三个参数，第一个 f 是一个函数，t1 和 t2 是传给 f 的参数。这个模板函数当然没啥作用，只是为了演示而已。可以直接调用 f，也可以通过模板函数 middle1 来调用 f，下面这段代码演示了两者的区别。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span>&amp; v2)</span> </span>&#123;  <span class="comment">// v2 是一个引用</span></span><br><span class="line">  ++v1;</span><br><span class="line">  ++v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">f</span>(<span class="number">42</span>, i);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;After call the f directly: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">middle1</span>(f, <span class="number">42</span>, i);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Call f through middle1: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><a target="_blank" rel="noopener" href="https://www.guodong.plus/2020/0314-132811/without_forward.jpg"><img src="C++%E6%9D%82%E9%A1%B9.assets/without_forward.jpg" alt="img"></a></p>
<p>注意函数 f 的参数 v2 是一个引用，在函数内部将 v1 和 v2 自增 1，预期应该是每次调用 f ，被 v2 引用的变量都可以加一。可以看到，在主函数中定义了一个变量 i，其初值为 0，直接调用 f 后，i 顺利的被加一，可是再次通过 middle1 调用 f 时，i 并没有加一。问题就出在 middle 上，虽然说 f 接收的参数是一个引用，但 middle 的参数却不是。当将 i 绑定到 middle 的参数 t2 上后，传给 f 的是 t2，而 t2 只是一个普通的、非引用的类型 int，而不是对 i 的引用。所以 i 的值并没有改变。</p>
<h2 id="保留类型信息"><a href="#保留类型信息" class="headerlink" title="保留类型信息"></a>保留类型信息</h2><p>再来看第二个版本的 middle，将 t1 和 t2 都定义为右值引用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">middle2</span><span class="params">(F f, T1&amp;&amp; t1, T2&amp;&amp; t2)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">f</span>(t1, t2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在刚刚的主函数中调用 middle2 而非 middle1，运行结果如下：</p>
<p><a target="_blank" rel="noopener" href="https://www.guodong.plus/2020/0314-132811/without_forward2.jpg"><img src="C++%E6%9D%82%E9%A1%B9.assets/without_forward2.jpg" alt="img"></a></p>
<p>可以看到，i 被顺利的自增了两次，也就是说，在 middle2 中，实参的“左值性“得到了保留。这就要归功于 <strong>引用折叠</strong> 了，简单说一下引用折叠：</p>
<ul>
<li>  <code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code> 和 <code>X&amp;&amp; &amp;</code> 都会折叠成类型 <code>X&amp;</code></li>
<li>  类型 <code>X&amp;&amp; &amp;&amp;</code> 折叠成 <code>X&amp;&amp;</code></li>
</ul>
<p>注意：引用折叠只能应用于间接创建的引用的引用，如类型别名或模板参数。就是说你不能这样直接用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; j = i; <span class="comment">// 很显然错了</span></span><br></pre></td></tr></table></figure>

<p>解释一下，可以看到上面两点中，&amp; 符号之间，有的有空格，有的没有，空格后面的部分可以认为是函数参数（形参）一开始的类型，而空格前面的是传递给函数的参数（实参）的类型。在我们的例子当中，middle2 的两个参数都是 &amp;&amp;（右值引用）类型的，而我们在 main 中调用 middle2 时，传给 t1 的是一个字面值 42，也就是右值，此时 t1 的类型为 <code>int&amp;&amp;</code> （其中 <code>int</code> 来自 T1），完全没问题，T1 被推导为 <code>int</code>。而传给 t2 的是一个引用类型 <code>int&amp;</code> （这里说的不清楚，有点错误，请看评论区），这时候，t2 的类型就变成了 <code>int&amp; &amp;&amp;</code>，按照引用折叠的规则，t2 就变成了 <code>int&amp;</code> 类型，而此时的模板参数 T2 将会被推导为 <code>int&amp;</code> 类型，这样，模板函数参数（形参）的完整类型就变成了 <code>int&amp; &amp;&amp;</code> （其中，<code>int&amp;</code> 来自 T2，<code>&amp;&amp;</code> 本来就存在），进而折叠为 <code>int&amp;</code> （与实参类型相匹配了）。</p>
<p>所以，通过将函数参数定义为一个指向模板类型参数的右值引用，就可以保持其对应实参的所有类型信息。而使用引用的情况下（无论左值还是右值），const 的属性都是可以保留的，因为 const 是类型的一部分，比如传给 middle2 的参数 t1 的是 const int，那么 T1 本身就会变成 const int，后面的 &amp;&amp; 才是附加的部分。</p>
<p>然而现实是残酷的，这个版本的 middle 只解决了一部分问题，考虑如下函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> &amp;&amp;v1, <span class="keyword">int</span>&amp; v2)</span> </span>&#123;</span><br><span class="line">  ++v1;</span><br><span class="line">  ++v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，i 是右值引用，我们在 main 函数中通过 middle2 调用 g：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">middle2</span>(g, <span class="number">42</span>, i);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Call g through middle2: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器报如下错误：</p>
<p><a target="_blank" rel="noopener" href="https://www.guodong.plus/2020/0314-132811/without_forward2_error_msg.jpg"><img src="C++%E6%9D%82%E9%A1%B9.assets/without_forward2_error_msg.jpg" alt="img"></a></p>
<p>无法将一个右值引用绑定到左值上。为什么会出现这个错误？我们在将 42 绑定给 t1 后，又将 t1 传递给了 g，本来我们应该期望没问题的，因为 g 的参数 v1 是右值引用，将 42 给右值引用完全没问题，但问题就出在，虽然 42 是右值，但 t1 却不是，上一篇博客说过了，变量都是左值，即使是右值引用，但也是变量，所以还是左值，而左值是无法与右值引用绑定的！</p>
<h2 id="std-forward"><a href="#std-forward" class="headerlink" title="std::forward"></a>std::forward</h2><p>那到底该怎么办呢，我们可以使用 forward 这个新标准库来传递 middle2 的参数，它能够保持原始实参的类型，forward 和 move 一起，都定义在 utility 头文件中。move 可以直接调用：<code>std::move(i)</code> ，但 foward 要明确给出模板参数：<code>std::foward&lt;int&gt;(i)</code> 才能使用。forward 会模板参数类型的右值引用，也就是：<code>int&amp;&amp;</code> 。注意，如果我们这样使用：<code>std::forward&lt;int&amp;&gt;(i)</code> 返回的就是 <code>int&amp; &amp;&amp;</code> ，进而折叠为 <code>int&amp;</code> 。</p>
<p>一般来说，模板函数中的参数类型为右值引用的时候，就需要搭配 forward 来使用，通过 forward 和引用折叠，就可以完美的保留参数类型了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">middle3</span><span class="params">(F f, T1&amp;&amp; t1, T2&amp;&amp; t2)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">f</span>(std::forward&lt;T1&gt;(t1), std::forward&lt;T2&gt;(t2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i, <span class="keyword">int</span>&amp; j)</span> </span>&#123;</span><br><span class="line">  ++i;</span><br><span class="line">  ++j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">middle3</span>(g, <span class="number">42</span>, i);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Call g through middle3: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><a target="_blank" rel="noopener" href="https://www.guodong.plus/2020/0314-132811/with_forward.jpg"><img src="C++%E6%9D%82%E9%A1%B9.assets/with_forward.jpg" alt="img"></a></p>
<p>可以看到，没有问题。分析一下：42 传递给 middle3 后，绑定到 t1 上，此时 t1 的类型为 <code>int&amp;&amp;</code> (其中，T1 被推导为 int)，然后我们通过 forward：<code>std::forward&lt;int&gt;(t1)</code>（T1 是 int 而不是 int&amp;&amp;） ，将返回 <code>int&amp;&amp;</code>，也就是说现在传给 g 的是一个右值引用了，可能你会有疑问：这不还是 <code>int&amp;&amp;</code> 吗？没变啊，为什么现在就可以和 g 中的右值引用绑定了，之前不也是 <code>int&amp;&amp;</code> 类型吗？注意：之前的右值引用叫“named rvalue“，也就是说，之前的右值引用是有名字的，叫 t1，而 t1 是一个变量！现在我们是返回一个右值引用，是没有名字的，所以是真正的右值。</p>
<p>对于左值引用 i，我们将 i 传递给 middle3 后，t2 的类型将变成 <code>int&amp; &amp;&amp;</code> ，经过引用折叠，变成了 <code>int&amp;</code> ，此时，如前所述，T2 将被推导为 <code>int&amp;</code> 类型。然后通过 <code>std::forward&lt;T2&gt;(t2)</code> =&gt; <code>std::forward&lt;int&amp;&gt;(t2)</code> ，将会返回一个 <code>int&amp; &amp;&amp;</code> ，折叠后变成 <code>int&amp;</code>，可以看到，左值引用也得到了保留！</p>
<h2 id="红黑树和AVL树"><a href="#红黑树和AVL树" class="headerlink" title="红黑树和AVL树"></a>红黑树和AVL树</h2><p><strong>AVL删除</strong>时不平衡会有向上传递的特性</p>
<p><strong>红黑树任何不平衡都会在三次旋转之内解决</strong></p>
<p><strong>一，AVL树（平衡二叉树）</strong><br><strong>（1）简介</strong><br>AVL树是带有平衡条件的二叉查找树，一般是用平衡因子差值判断是否平衡并通过旋转来实现平衡，<strong>左右子树的高度差不超过1</strong>，和红黑树相比，<strong>AVL树是严格的平衡二叉树</strong>，平衡条件必须满足（所有节点的左右子树高度差的绝对值不超过1）。<strong>不管我们是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡</strong>，而旋转是非常耗时的，由此我们可以知道<strong>AVL树适合用于插入与删除次数比较少，但查找多的情况。</strong><br><strong>（2）局限性</strong><br>由于维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，<strong>如果应用场景中对插入删除不频繁，只是对查找要求较高，那么AVL还是较优于红黑树</strong>。<br><strong>（3）应用</strong><br>1.Windows NT内核中广泛存在;</p>
<p><strong>二、红黑树</strong><br><strong>（1）简介</strong><br>一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，<strong>红黑树确保没有一条路径会比其它路径长出两倍（即同一父节点出发到叶子节点，所有路径上的黑色节点数目一样）</strong>，因此，<strong>红黑树是一种弱平衡二叉树，在相同的节点情况下，AVL树的高度低于红黑树</strong>，<strong>相对于要求严格的AVL树来说，它的旋转次数少，所以对于插入，删除操作较多的情况下，我们就用红黑树</strong>。<br><strong>（2）性质</strong></p>
<ol>
<li><p> 每个节点非红即黑</p>
</li>
<li><p> 如果一个节点是红的，那么它的两儿子都是黑的;</p>
</li>
<li><p> 根节点和叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的;</p>
</li>
<li><p>对于任意节点而言，其到叶节点NULL指针的每条路径都包含相同数目的黑节点;</p>
<p> 左根右，根叶黑，不红红，黑路同</p>
<p> <strong>（3）应用</strong></p>
</li>
<li><p> 广泛用于C ++的STL中，地图和集都是用红黑树实现的;</p>
</li>
<li><p> Linux的进程调度完全公平调度程序，用红黑树管理进程控制块，进程的虚拟内存区域都存储在一颗红黑树上，每个虚拟地址区域都对应红黑树的一个节点，左指针指向相邻的地址虚拟存储区域，右指针指向相邻的高地址虚拟地址空间;</p>
</li>
<li><p> IO多路复用的epoll的实现采用红黑树组织管理的的的sockfd，以支持快速的增删改查;</p>
</li>
<li><p> Nginx的的的中用红黑树管理定时器，因为红黑树是有序的，可以很快的得到距离当前最小的定时器;</p>
</li>
<li><p> Java的的的中TreeMap中的中的实现;</p>
</li>
</ol>
<p><strong>三、红黑树与AVL树区别</strong><br><strong>1、调整平衡的实现机制不同</strong></p>
<p>红黑树根据节点颜色(<strong>同一父节点出发到叶子节点，所有路径上的黑色节点数目一样</strong>)，一些约定和旋转实现；</p>
<p>AVL根据树的平衡因子(<strong>所有节点的左右子树高度差的绝对值不超过1</strong>)和旋转决定</p>
<p><strong>2、红黑树的插入效率更高</strong></p>
<p>红黑树是用非严格的平衡来换取增删节点时候旋转次数的降低，任何不平衡都会在三次旋转之内解决，红黑树并不追求“完全平衡”，它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能</p>
<p>而AVL是严格平衡树(高度平衡的二叉搜索树)，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多。所以红黑树的插入效率更高</p>
<p><strong>3、红黑树统计性能比AVL树更高</strong></p>
<p>红黑树能够以<strong>O(log n)</strong> 的时间复杂度进行查询、插入、删除操作。</p>
<p>AVL树查找、插入和删除在平均和最坏情况下都是**O(log n)**。</p>
<p>红黑树的算法时间复杂度和AVL相同，<strong>但统计性能比AVL树更高</strong>，典型的用途是实现关联数组。</p>
<p><strong>4、适用性：AVL查找效率高</strong></p>
<p><strong>如果你的应用中，查询的次数远远大于插入和删除，那么选择AVL树，如果查询和插入删除次数几乎差不多，应选择红黑树</strong>。即，有时仅为了排序（建立-遍历-删除），不查找或查找次数很少，R-B树合算一些。</p>
<h2 id="emplace-back-和-push-back"><a href="#emplace-back-和-push-back" class="headerlink" title="emplace_back 和 push_back"></a>emplace_back 和 push_back</h2><p>emplace_back()是c++11的新特性。<br>和push_back()的区别在于<br>push_back()方法要调用构造函数和复制构造函数，这也就代表着要先构造一个临时对象，然后把临时的copy构造函数拷贝或者移动到容器最后面。<br>而emplace_back()在实现时，则是直接在容器的尾部创建这个元素，省去了拷贝或移动元素的过程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shallowshades.github.io.git/2022/06/22/C++%E8%BF%9B%E9%98%B6/" data-id="clca7m48g000dxog03kij4z6e" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Linux高并发服务器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/06/22/Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="article-date">
  <time datetime="2022-06-22T03:41:05.000Z" itemprop="datePublished">2022-06-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/06/22/Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/">Linux高并发服务器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">ubuntu</span></span><br><span class="line">tar -zxvf redis-5.0.10.tar.gz											#解压tar.gz文件</span><br><span class="line"></span><br><span class="line">apt-get update															#更新软件包列表</span><br><span class="line">apt-get install package													#软件安装库安装</span><br><span class="line">dpkg -i pkg.deb															#安装已经下载的软件包</span><br><span class="line">dpkg -l																	#查看安装的所有软件</span><br><span class="line">apt-get remove package													#删除软件包</span><br><span class="line">apt-get -s update/dist-update											#软件包测试的升级</span><br><span class="line">apt-get upgrade															#升级软件包</span><br><span class="line">apt-get dist-upgrade													#升级整个系统</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">CentOS</span></span><br><span class="line">																		#自动更新软件包列表</span><br><span class="line">yum install package														#软件安装库安装</span><br><span class="line">yum install pkg.rpm														#安装已经下载的软件包</span><br><span class="line">yum list installed 														#查看安装的所有软件</span><br><span class="line">yum -e package															#删除软件包</span><br><span class="line">yum check-update														#软件包测试的升级</span><br><span class="line">yum update / rpm -Uvh[args]											    #升级软件包</span><br><span class="line">yum upgrade																#升级整个系统</span><br></pre></td></tr></table></figure>



<h1 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h1><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p> <strong>Ubuntu</strong></p>
<p>软件包的后缀：xxx.deb</p>
<p>软件源配置文件：/etc/apt/sources.list</p>
<p><strong>CentOS</strong></p>
<p>来自redhat，所以centos支持rpm格式的安装，而ubuntu显然是不支持的。</p>
<p>软件包后缀：xxx.rpm</p>
<p>软件源配置文件：/etc/yum.conf</p>
<h2 id="Ubuntu18"><a href="#Ubuntu18" class="headerlink" title="Ubuntu18"></a>Ubuntu18</h2><p>安装vm-tools实现屏幕适应，以及拖拽文件实现主机和虚拟机的文件传输</p>
<p><em>出了问题无法实现拖拽</em></p>
<p>安装Xshell、xftp实现远程连接和文件传输</p>
<h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p><strong>解决每次登录输入密码</strong></p>
<p>在主机上命令行输入 <strong>ssh-keygen -t rsa</strong> 生成到用户目录下，生成密钥。</p>
<p>在虚拟机终端输入<strong>ssh-keygen -t rsa</strong> 生成密钥；</p>
<p>然后，vim authorized_keys,将主机的公钥复制到文件中</p>
<h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><p>GCC原名为GNU C语言编译器(GNU C Compiler)</p>
<p>GCC (GNU Compiler Collection， GNU编译器套件)是由GNU开发的编程语言译器。GNU编译器套件包括C、C++、objective-C、Java、Ada和Go语言前端，也包括了这些语言的库(如libstdc++， libgcj等)</p>
<p>GCC不仅支持C的许多“方言”，也可以区别不同的C语言标准;可以使用命令行选项来控制编译器在翻译源代码时应该遵循哪个C标准。例如，当使用命令行参数-std=c99i 启动GCC时，编译器支持C99标准。</p>
<p>安装命令sudo apt install gcc g++ (版本&gt; 4.8.5)</p>
<p>查看版本gcc/g++ -v/–version</p>
<p><strong>工作流程</strong></p>
<p><img src="Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8.assets/image-20220623015304592.png" alt="image-20220623015304592"></p>
<p><strong>编译选项</strong></p>
<p><img src="Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8.assets/image-20220623015237929.png" alt="image-20220623015237929"></p>
<p><img src="Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8.assets/image-20220623022555771.png" alt="image-20220623022555771"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">gcc -E a.c -o a.i # 预处理</span><br><span class="line">gcc -S a.i -o a.s # 编译</span><br><span class="line">gcc -c a.s -o a.o # 汇编</span><br><span class="line">gcc	a.o b.o -o a.out # 链接</span><br><span class="line">gcc a.c -l pthread -o a # 手动添加链接库</span><br><span class="line">-o # 指定生成文件名称</span><br><span class="line">-L # 指定包含库的的搜索目录</span><br><span class="line">-I # 指定 include 包含文件的搜索目录</span><br><span class="line">-g # 生成调试信息，用于 GDB</span><br><span class="line">-D # 指定一个宏</span><br><span class="line">-w # 不生成警告</span><br><span class="line">-Wall # 生成所有警告</span><br><span class="line">-On # 优化等级 0-3（0没有，1默认）</span><br><span class="line">-std # 指定 C 方言，如 -std = C99</span><br></pre></td></tr></table></figure>

<p>我们看下 <code>-D</code> ，这个的作用就是指定一个宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;log out.\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们加入了 <code>-D DEBUG</code> 那么就会输出 <code>log</code> ，否则，不会输出。</p>
<p>可以认为 <code>g++ = gcc -lstdc++</code> 链接了 <code>C++</code> 库。</p>
<h2 id="静态库的制作与使用"><a href="#静态库的制作与使用" class="headerlink" title="静态库的制作与使用"></a>静态库的制作与使用</h2><p>命名：</p>
<ul>
<li>  <code>Linux</code>：<code>libxxx.a</code></li>
<li>  <code>Windows</code>：<code>lixxxx.lib</code></li>
</ul>
<p>优点：</p>
<ul>
<li>  安全，可以不用提供源程序，保护俺的知识产权</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">➜  nowcoker tree # 一个项目的一般结构          </span><br><span class="line">.</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── lib</span><br><span class="line">├── main.c</span><br><span class="line">└── src</span><br><span class="line">    ├── add.c</span><br><span class="line">    ├── div.c</span><br><span class="line">    ├── mult.c</span><br><span class="line">    └── sub.c</span><br><span class="line"></span><br><span class="line">3 directories, 6 files</span><br><span class="line">➜  nowcoker cd src </span><br><span class="line">➜  src gcc -c add.c div.c sub.c mult.c -I ../include </span><br><span class="line">➜  src ar rcs libcalc.a add.o div.o mult.o sub.o # ar 就是生成静态库的命令</span><br><span class="line">➜  src mv libcalc.a ../lib </span><br><span class="line">➜  src cd ..</span><br><span class="line">➜  nowcoker gcc main.c -o calculate -I ./include -L ./lib -l calc</span><br><span class="line">➜  nowcoker ./calculate </span><br><span class="line">2 + 2 = 4</span><br><span class="line">2 - 2 = 0</span><br><span class="line">2 * 2 = 4</span><br><span class="line">2 / 2 = 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 只需要提供 include 和 lib ，src 自己保存就好</span></span><br></pre></td></tr></table></figure>

<h2 id="动态库的制作与使用"><a href="#动态库的制作与使用" class="headerlink" title="动态库的制作与使用"></a>动态库的制作与使用</h2><p>命名规则：</p>
<ul>
<li>  <code>Linux</code>：<code>libxxx.so</code></li>
<li>  <code>Windows</code>：<code>libxxx.dll</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">➜  nowcoker tree</span><br><span class="line">.</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── lib</span><br><span class="line">├── main.c</span><br><span class="line">└── src</span><br><span class="line">    ├── add.c</span><br><span class="line">    ├── div.c</span><br><span class="line">    ├── mult.c</span><br><span class="line">    └── sub.c</span><br><span class="line"></span><br><span class="line">3 directories, 6 files</span><br><span class="line">➜  nowcokercd src                   </span><br><span class="line">➜  src gcc -c -fPIC *.c -I ../include # 得到和位置无关的 .o 文件</span><br><span class="line">➜  src gcc -shared *.o -o libcalc.so # 制作动态库</span><br><span class="line">➜  src mv libcalc.so ../lib </span><br><span class="line">➜  src cd ..</span><br><span class="line">➜  nowcoker gcc main.c -o calculate -I ./include -L lib -l calc # 只加载了动态库信息</span><br><span class="line">➜  nowcoker ldd calculate # 检查动态库依赖关系</span><br><span class="line">        linux-vdso.so.1 (0x00007fff45de1000)</span><br><span class="line">        libcalc.so =&gt; not found # 找不到</span><br><span class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fa62d052000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007fa62d288000)</span><br><span class="line">➜  nowcoker ./calculate </span><br><span class="line">./calculate: error while loading shared libraries: libcalc.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>

<p>对于 <code>elf</code> 格式的可执行程序，是由 <code>ld-linux.so</code> （动态载入器）来完成的，它先后搜索 <code>elf</code> 文件的 <code>DT_RPATH</code> 段 ——&gt; 环境变量 <code>LD_LIBRARY_PATH</code> ——&gt; <code>/etc/ld.so.cache</code> 文件列表 ——&gt; <code>/lib/，/usr/lib</code> 目录找到库文件后将其载入内存。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 终端临时添加</span></span><br><span class="line">➜  nowcoker pwd</span><br><span class="line">/home/ceyewan/CodeField/CODE_CPP/nowcoker</span><br><span class="line">➜  nowcoker export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/ceyewan/CodeField/CODE_CPP/nowcoker/lib</span><br><span class="line">➜  nowcoker ldd calculate</span><br><span class="line">        linux-vdso.so.1 (0x00007ffc00dff000)</span><br><span class="line">        libcalc.so =&gt; /home/ceyewan/CodeField/CODE_CPP/nowcoker/lib/libcalc.so (0x00007fb9f2606000)</span><br><span class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fb9f23d7000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007fb9f2612000)</span><br><span class="line">➜  nowcoker ./calculate </span><br><span class="line">2 + 2 = 4</span><br><span class="line">2 - 2 = 0</span><br><span class="line">2 * 2 = 4</span><br><span class="line">2 / 2 = 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 用户级别</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 <span class="built_in">export</span> 命令加入到 ~/.bashrc 并 <span class="built_in">source</span> 使之生效</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 系统级别</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 <span class="built_in">export</span> 命令到 /etc/profile 并 <span class="built_in">source</span> 使之生效</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可在 /etc/ld.so.conf 中直接添加路径</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 环境变量 LD_LIBRARY_PATH</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 用户级别配置</span></span><br><span class="line">cd ~</span><br><span class="line">vim .bashrc</span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/shallow/Linux/lesson06/library/lib	#添加动态库的绝对路径</span><br><span class="line">. .bashrc/source .bashrc															#使配置生效</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 系统级配置</span></span><br><span class="line">sudo vim /etc/profile</span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/shallow/Linux/lesson06/library/lib	#添加动态库的绝对路径</span><br><span class="line">. /etc/profile</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># etc/ld.so.cache文件列表</span></span></span><br><span class="line">sudo vim /etc/ld.so.conf															#配置</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加动态库路径 /home/shallow/Linux/lesson06/library/lib</span></span><br><span class="line">sudo ldconfig																		#使配置生效</span><br></pre></td></tr></table></figure>


<ul>
<li>静态库：<ul>
<li>  <code>GCC</code> 进行链接时，会把静态库中代码打包到可执行程序中</li>
<li>  优点，使用简单</li>
<li>  缺点，造成可执行文件体积庞大，重复加载等</li>
</ul>
</li>
<li>动态库：<ul>
<li>  <code>GCC</code> 进行链接时，动态库的代码不会被打包到可执行程序中</li>
<li>  缺点：使用复杂</li>
<li>  优点：无需加载，速度快，共享使用（加载到内存后可以供多个进程使用）</li>
</ul>
</li>
</ul>
<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><ul>
<li>  <code>Makefile</code>：自动化编译，编译顺序、重新编译等复杂功能。</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"><span class="section">xxx[目标]: xxx[依赖]</span></span><br><span class="line">	xxx[shell 命令]</span><br></pre></td></tr></table></figure>

<p>变量：</p>
<ul>
<li>  自定义变量 变量名=变量值 <code>var=hello</code></li>
<li>  <code>AR</code>：归档维护程序的名称，默认为 <code>ar</code></li>
<li>  <code>CC</code>：<code>C</code> 编译器的名称，默认值为 <code>cc</code></li>
<li>  <code>CXX</code>：<code>C++</code> 编译器的名称，默认值为 <code>g++</code></li>
<li>  <code>$@</code>：目标的完整名称</li>
<li>  <code>$&lt;</code>：第一个依赖的文件的名称</li>
<li>  <code>$^</code>：所有的依赖文件</li>
<li>  获取变量的值，<code>$(变量名)</code></li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MAKEFILE</span><br><span class="line">src=sub.c add.c mult.c div.c</span><br><span class="line">target=calculate</span><br><span class="line"><span class="variable">$(target)</span>: <span class="variable">$(src)</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>模式匹配：</p>
<ul>
<li>  <code>%</code>：通配符，匹配一个字符串，<code>%.o: %.c</code> ，两个 <code>%</code> 匹配的是同一个字符串。</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MAKEFILE</span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>函数：</p>
<ul>
<li><p>```makefile<br>  $(wildcard PATTERN…)</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    -   获取指定目录下指定类型的文件列表</span><br><span class="line">    -   `$(wildcard *.c ./src/*.c)` 得到当前目录和 `src` 目录下的 `.c` 文件</span><br><span class="line"></span><br><span class="line">-   ```makefile</span><br><span class="line">    $(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</span><br></pre></td></tr></table></figure>

<ul>
<li>  查找 <code>&lt;text&gt;</code> 中的单词是否符合模式 <code>&lt;pattern&gt;</code> ，如果匹配的话，则以 <code>&lt;replacement&gt;</code> 替换</li>
<li>  <code>$(patsubst %.c, %.o, a.c b.c)</code> 返回 <code>a.o</code> 和 <code>b.o</code></li>
</ul>
</li>
</ul>
<p><code>clean</code> 功能：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MAKEFILE</span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm *.o -f</span><br></pre></td></tr></table></figure>

<p>编译一下我们的计算器，</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MAKEFILE</span><br><span class="line">src=<span class="variable">$(<span class="built_in">wildcard</span> *.c ./src/*.c)</span></span><br><span class="line">objs=<span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span></span><br><span class="line">target=calculate</span><br><span class="line"></span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(objs)</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$(target)</span> -I ./<span class="keyword">include</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span> -I ./<span class="keyword">include</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f <span class="variable">$(objs)</span></span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">➜  nowcoker make      </span><br><span class="line">cc -c main.c -o main.o -I ./<span class="keyword">include</span></span><br><span class="line">cc -c src/add.c -o src/add.o -I ./<span class="keyword">include</span></span><br><span class="line">cc -c src/div.c -o src/div.o -I ./<span class="keyword">include</span></span><br><span class="line">cc -c src/mult.c -o src/mult.o -I ./<span class="keyword">include</span></span><br><span class="line">cc -c src/sub.c -o src/sub.o -I ./<span class="keyword">include</span></span><br><span class="line">cc main.o src/add.o src/div.o src/mult.o src/sub.o -o calculate -I ./<span class="keyword">include</span></span><br><span class="line">➜  nowcoker make clean</span><br><span class="line">rm  main.o  ./src/add.o  ./src/div.o  ./src/mult.o  ./src/sub.o</span><br></pre></td></tr></table></figure>

<p>参考资料：</p>
<blockquote>
<p>  <a target="_blank" rel="noopener" href="https://seisman.github.io/how-to-write-makefile/index.html">https://seisman.github.io/how-to-write-makefile/index.html</a></p>
</blockquote>
<h2 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h2><p>准备工作：</p>
<ul>
<li>  关闭 <code>-O</code>优化，开启 <code>-Wall</code> 显示更多的 <code>warning</code></li>
<li>  开启 <code>-g</code> 选项，在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证 <code>gdb</code> 能找到源文件。</li>
</ul>
<p>GDB命令：</p>
<ul>
<li>  启动 <code>gdb 可执行程序</code></li>
<li>  退出 <code>quit/q</code></li>
<li>  给程序设置参数，<code>set args 10 20</code> ，显示参数，<code>show args</code></li>
<li>  使用帮助 <code>help [xxx]</code></li>
<li>  查看当前文件代码 <code>list/l [xx](行号/函数名/文件名:行号/文件名:函数名)</code></li>
<li>  设置显示的行数，<code>show[set] list/listsize</code></li>
<li>  设置断点，<code>break/b [xx](行号/函数名/文件名:行号/文件名:函数名)</code></li>
<li>  查看断点，<code>info/i b/break</code></li>
<li>  删除断点，<code>d/del/delete 断点编号</code></li>
<li>  设置断点无效/生效，<code>dis/disable[ena/enable] 断点编号</code></li>
<li>  设置条件断点，一般用于循环，<code>b 10 if i==5</code></li>
<li>  运行 <code>gdb</code> 程序，<code>start(程序停在第一行)</code>，<code>run(遇到断点才停)</code></li>
<li>  继续运行，下个断点停，<code>continue/c</code></li>
<li>  向下执行一行代码，不进入函数体，<code>next/n</code></li>
<li>  向下单步调试，进入函数体，<code>step/s</code>，跳出函数体，<code>finish</code></li>
<li>  变量输出，<code>print/p 变量名</code>，<code>ptype 变量名</code></li>
<li>  自动变量操作，自动打印指定变量的值，<code>display 变量名</code></li>
<li>  修改变量的值，<code>set var 变量名=变量值</code>；跳出循环，<code>until</code></li>
</ul>
<h2 id="标准-C-库和-Linux-系统-IO-函数的对比"><a href="#标准-C-库和-Linux-系统-IO-函数的对比" class="headerlink" title="标准 C 库和 Linux 系统 IO 函数的对比"></a>标准 C 库和 Linux 系统 IO 函数的对比</h2><p>就以 <code>fopen</code> 和 <code>open</code> 函数为例，我们来看看区别：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">char</span> *filename, <span class="keyword">char</span> *mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> access,<span class="keyword">int</span> mode)</span></span>;</span><br><span class="line"><span class="comment">/* open 是系统提供的，fopen 是标准 C 库函数</span></span><br><span class="line"><span class="comment"> fopen 是封装了 open 的具有缓冲区的更高一级的函数，可以跨平台使用*/</span></span><br></pre></td></tr></table></figure>

<h2 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h2><p>分为内核区和用户区，虚拟内存由操作系统管理。</p>
<h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>内核区的进程控制块（PCB），维护文件描述符表，我们可以通过内核区的 <code>PCB</code> 中的文件描述符表查找文件描述符来定位文件的位置。</p>
<blockquote>
<p>  前 3 个文件描述符，默认已经打开</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> -&gt; STDIN</span><br><span class="line"><span class="number">1</span> -&gt; STDOUT</span><br><span class="line"><span class="number">2</span> -&gt; STDERR</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="open-函数"><a href="#open-函数" class="headerlink" title="open 函数"></a>open 函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># man open</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">// pathname: 要打开文件的路径</span></span><br><span class="line"><span class="comment">// flags: 操作权限(O_RDONLY, O_WRONLY, O_RDWR)</span></span><br><span class="line"><span class="comment">// 返回文件描述符，如果出错就返回 -1 ,c错误信息可以使用 perror 查看</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="comment">// mode: 一个八进制的数，表示对创建文件的权限（一般用于创建文件）777 表示最高权限（3种不同类型的用户的权限）</span></span><br></pre></td></tr></table></figure>

<p>例如如果打开一个不存在的文件，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = open(<span class="string">&quot;log.txt&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="comment">// int fd = open(&quot;log.txt&quot;, O_RDONLY | O_CREAT, 0777);</span></span><br><span class="line"><span class="comment">// 0777 作用是指定文件本身的权限， flags 是指定程序对文件的权限</span></span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">	perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  nowcoker ./a.out </span><br><span class="line">open: No such file or directory</span><br></pre></td></tr></table></figure>

<h2 id="read-和-write-函数"><a href="#read-和-write-函数" class="headerlink" title="read 和 write 函数"></a>read 和 write 函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="comment">// fd 文件描述符</span></span><br><span class="line"><span class="comment">// buf 存储读取内容的缓冲区</span></span><br><span class="line"><span class="comment">// 一次读取的数量</span></span><br><span class="line"><span class="comment">// 返回实际读取的数量，-1 表述出错</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="comment">// buf 存储写入内容的缓冲区</span></span><br><span class="line"><span class="comment">// 一次写入的数量</span></span><br><span class="line"><span class="comment">// 返回实际写入的数量，-1 表述出错</span></span><br><span class="line"><span class="keyword">int</span> srcfd = open(<span class="string">&quot;src.txt&quot;</span>, O_RDONLY);</span><br><span class="line">assert(srcfd != <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> destfd = open(<span class="string">&quot;copy.txt&quot;</span>, O_WRONLY | O_CREAT, <span class="number">0777</span>);</span><br><span class="line">assert(destfd != <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">char</span>* buffer = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * <span class="number">12</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> rc = read(srcfd, buffer, <span class="number">10</span>);</span><br><span class="line">    assert(rc &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rc = write(destfd, buffer, rc); <span class="comment">// 上面读 rc 个，这里写 rc 个</span></span><br><span class="line">    assert(rc &gt;= <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">close(srcfd);</span><br><span class="line">close(destfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h2 id="lseek-函数"><a href="#lseek-函数" class="headerlink" title="lseek 函数"></a>lseek 函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">lseek</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset,  <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"><span class="comment">/*  fd 文件描述符</span></span><br><span class="line"><span class="comment">offset 文件指针的移动量</span></span><br><span class="line"><span class="comment">whence</span></span><br><span class="line"><span class="comment">	- SEEK_SET，起始偏移量为 0</span></span><br><span class="line"><span class="comment">	- SEEK_CUR，起始偏移量为当前位置</span></span><br><span class="line"><span class="comment">	- SEEK_END，起始偏移量为最后位置</span></span><br><span class="line"><span class="comment">返回值，文件指针移动后的位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">&quot;src.txt&quot;</span>, O_RDWR);</span><br><span class="line">assert(fd != <span class="number">-1</span>);</span><br><span class="line"><span class="comment">// 移动文件指针到文件头, 读取 5 个字符</span></span><br><span class="line">lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">read(fd, buf, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line"><span class="comment">// 此时位置为 5 ，我们跳过 &quot; &quot;，偏移一位</span></span><br><span class="line">lseek(fd, <span class="number">1</span>, SEEK_CUR);</span><br><span class="line">read(fd, buf, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line"><span class="comment">// 文件指针从最后回退 6 个字符（包括结尾符，&#x27;\0&#x27;</span></span><br><span class="line">lseek(fd, <span class="number">-6</span>, SEEK_END);</span><br><span class="line">read(fd, buf, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line"><span class="comment">// 拓展文件大小，可用于提前申请空间</span></span><br><span class="line">lseek(fd, <span class="number">100</span>, SEEK_END);</span><br><span class="line">write(fd, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">➜  nowcoker touch src.txt</span><br><span class="line">➜  nowcoker echo <span class="string">&quot;hello world&quot;</span> &gt; src.txt</span><br><span class="line">➜  nowcoker ll</span><br><span class="line">-rw-r--r-- <span class="number">1</span> ceyewan ceyewan   <span class="number">12</span>  <span class="number">6</span>月 <span class="number">18</span> <span class="number">23</span>:<span class="number">41</span> src.txt</span><br><span class="line">➜  nowcoker gcc a.c </span><br><span class="line">➜  nowcoker ./a.out </span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">world</span><br><span class="line">➜  nowcoker ll</span><br><span class="line">-rw-r--r-- <span class="number">1</span> ceyewan ceyewan  <span class="number">113</span>  <span class="number">6</span>月 <span class="number">18</span> <span class="number">23</span>:<span class="number">52</span> src.txt</span><br></pre></td></tr></table></figure>

<h2 id="stat-和-lstat-函数"><a href="#stat-和-lstat-函数" class="headerlink" title="stat 和 lstat 函数"></a>stat 和 lstat 函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *buf)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">	    <span class="keyword">dev_t</span>          st_dev;        <span class="comment">//文件的设备编号</span></span><br><span class="line">	    <span class="keyword">ino_t</span>           st_ino;        <span class="comment">//节点</span></span><br><span class="line">	    <span class="keyword">mode_t</span>         st_mode;      <span class="comment">//文件的类型和存取的权限</span></span><br><span class="line">	    <span class="keyword">nlink_t</span>         st_nlink;     <span class="comment">//连到该文件的硬连接数目，刚建立的文件值为1</span></span><br><span class="line">	    <span class="keyword">uid_t</span>           st_uid;       <span class="comment">//用户ID</span></span><br><span class="line">	    <span class="keyword">gid_t</span>           st_gid;       <span class="comment">//组ID</span></span><br><span class="line">	    <span class="keyword">dev_t</span>          st_rdev;      <span class="comment">//(设备类型)若此文件为设备文件，则为其设备编号</span></span><br><span class="line">	    <span class="keyword">off_t</span>          st_size;      <span class="comment">//文件字节数(文件大小)</span></span><br><span class="line">	    <span class="keyword">blksize_t</span>       st_blksize;   <span class="comment">//块大小(文件系统的I/O 缓冲区大小)</span></span><br><span class="line">	    <span class="keyword">blkcnt_t</span>        st_blocks;    <span class="comment">//块数</span></span><br><span class="line">	    <span class="keyword">time_t</span>         st_atime;     <span class="comment">//最后一次访问时间</span></span><br><span class="line">	    <span class="keyword">time_t</span>         st_mtime;     <span class="comment">//最后一次修改时间</span></span><br><span class="line">	    <span class="keyword">time_t</span>         st_ctime;     <span class="comment">//最后一次改变时间(指属性)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li> 对于普通文件，这两个函数没有区别</li>
<li> 对于连接文件，<code>lstat</code> 获取的是链接文件本身的属性，<code>stat</code> 获取的是链接文件指向文件的属性信息</li>
</ol>
<h2 id="文件属性操作函数"><a href="#文件属性操作函数" class="headerlink" title="文件属性操作函数"></a>文件属性操作函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line"><span class="comment">// 检查是否对文件有 mode 的权限，是返回 0 ，否 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chmod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line"><span class="comment">// 修改文件权限为 mode</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="comment">// 改变文件所有者</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">truncate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">off_t</span> length)</span></span>;</span><br><span class="line"><span class="comment">// 改变 path 文件的大小为 length</span></span><br></pre></td></tr></table></figure>

<h2 id="目录操作函数"><a href="#目录操作函数" class="headerlink" title="目录操作函数"></a>目录操作函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="comment">// pathname: 创建目录的路径</span></span><br><span class="line"><span class="comment">// mode: 权限</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"><span class="comment">// 改变当前工作目录为 path</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">// 返回当前工作目录，参数可为 null ，buf 中也存储返回结果</span></span><br></pre></td></tr></table></figure>

<h2 id="目录遍历函数"><a href="#目录遍历函数" class="headerlink" title="目录遍历函数"></a>目录遍历函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="comment">// 打开目录返回目录流（目录里面有很多东西</span></span><br><span class="line"><span class="function">struct dirent *<span class="title">readdir</span><span class="params">(DIR *dirp)</span></span>;</span><br><span class="line"><span class="comment">// 一个从目录流中读取一个文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *drip)</span></span>;</span><br><span class="line"><span class="comment">// 关闭目录流</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">    <span class="comment">// 此目录进入点的inode</span></span><br><span class="line">    <span class="keyword">ino_t</span> d_ino;</span><br><span class="line">    <span class="comment">// 目录文件开头至此目录进入点的位移</span></span><br><span class="line">    <span class="keyword">off_t</span> d_off;</span><br><span class="line">    <span class="comment">// d_name 的长度, 不包含NULL字符</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> d_reclen;</span><br><span class="line">    <span class="comment">// d_name 所指的文件类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> d_type;</span><br><span class="line">    <span class="comment">// 文件名</span></span><br><span class="line">    <span class="keyword">char</span> d_name[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* d_type</span></span><br><span class="line"><span class="comment">DT_BLK - 块设备  DT_CHR - 字符设备</span></span><br><span class="line"><span class="comment">DT_DIR - 目录		DT_LNK - 软连接</span></span><br><span class="line"><span class="comment">DT_FIFO - 管道   DT_REG - 普通文件</span></span><br><span class="line"><span class="comment">DT_SOCK - 套接字  DT_UNKNOWN - 未知 */</span></span><br></pre></td></tr></table></figure>

<h2 id="dup-和-dup2-函数"><a href="#dup-和-dup2-函数" class="headerlink" title="dup 和 dup2 函数"></a>dup 和 dup2 函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br><span class="line"><span class="comment">// 复制文件描述符，返回值和 oldfd 指向同一文件，共享文件指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</span><br><span class="line"><span class="comment">// 重定向文件描述符，关闭 newfd 指向的文件，然后 newfd 指向 oldfd 指向的文件，返回 newfd </span></span><br></pre></td></tr></table></figure>

<h2 id="fcntl-函数"><a href="#fcntl-函数" class="headerlink" title="fcntl 函数"></a>fcntl 函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* args */</span>)</span></span>;</span><br><span class="line"><span class="comment">/* fd : 文件描述符</span></span><br><span class="line"><span class="comment">cmd：表示对文件描述符进行如何操作</span></span><br><span class="line"><span class="comment">	- F_DUPFD 复制文件描述符，等价于 dup</span></span><br><span class="line"><span class="comment">		fcntl(fd, F_DUPFD);</span></span><br><span class="line"><span class="comment">	- F_GETFL 获取文件描述符的 flag（就是 open 时指定的 flag）</span></span><br><span class="line"><span class="comment">		int flag = fcntl(fd, F_GETFL);</span></span><br><span class="line"><span class="comment">	- F_SETFL 设置文件描述符文件状态 flag</span></span><br><span class="line"><span class="comment">		- 必选项：O_PDONLY O_WRONLY O_RDWR</span></span><br><span class="line"><span class="comment">		- 可选项：O_APPEND追加数据</span></span><br><span class="line"><span class="comment">						NONBLOCK 设置成非阻塞*/</span></span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">int</span> flag = fcntl(fd, F_GETFL);</span><br><span class="line">fcntl(fd, G_SETFL, flag | O_APPEND); <span class="comment">// 设置成追加写入</span></span><br></pre></td></tr></table></figure>

<h2 id="模拟实现-ls-l-命令"><a href="#模拟实现-ls-l-命令" class="headerlink" title="模拟实现 ls -l 命令"></a>模拟实现 ls -l 命令</h2><p>打开当前目录，然后遍历目录，调用 <code>showFile</code> 函数显示该目录下所有文件的信息，文件夹同样是文件，一切皆文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showFiles</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DIR *dir = opendir(pathname);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">d</span>;</span></span><br><span class="line">    <span class="keyword">while</span> ((d = readdir(dir)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(d-&gt;d_name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(d-&gt;d_name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        showFile(d-&gt;d_name);</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取文件信息，最复杂的就是权限信息的显示了，</p>
<p><a target="_blank" rel="noopener" href="http://www.ceyewan.top/images/image-20220619140904963.png"><img src="Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8.assets/image-20220619140904963.png" alt="image-20220619140904963"></a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="keyword">int</span> rc = stat(filename, &amp;st);</span><br><span class="line">    <span class="keyword">if</span> (rc == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> perms[<span class="number">11</span>];</span><br><span class="line">    <span class="keyword">switch</span> (st.st_mode &amp; S_IFMT)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> S_IFLNK:</span><br><span class="line">        perms[<span class="number">0</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> S_IFDIR:</span><br><span class="line">        perms[<span class="number">0</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> S_IFREG:</span><br><span class="line">        perms[<span class="number">0</span>] = <span class="string">&#x27;_&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> S_IFBLK:</span><br><span class="line">        perms[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> S_IFCHR:</span><br><span class="line">        perms[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> S_IFSOCK:</span><br><span class="line">        perms[<span class="number">0</span>] = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> S_IFIFO:</span><br><span class="line">        perms[<span class="number">0</span>] = <span class="string">&#x27;p&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        perms[<span class="number">0</span>] = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件所有者</span></span><br><span class="line">    perms[<span class="number">1</span>] = (st.st_mode &amp; S_IRUSR) ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">2</span>] = (st.st_mode &amp; S_IWUSR) ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">3</span>] = (st.st_mode &amp; S_IXUSR) ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件所在组</span></span><br><span class="line">    perms[<span class="number">4</span>] = (st.st_mode &amp; S_IRGRP) ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">5</span>] = (st.st_mode &amp; S_IWGRP) ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">6</span>] = (st.st_mode &amp; S_IXGRP) ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他人</span></span><br><span class="line">    perms[<span class="number">7</span>] = (st.st_mode &amp; S_IROTH) ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">8</span>] = (st.st_mode &amp; S_IWOTH) ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">9</span>] = (st.st_mode &amp; S_IXOTH) ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 硬连接数</span></span><br><span class="line">    <span class="keyword">int</span> linkNum = st.st_nlink;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件所有者</span></span><br><span class="line">    <span class="keyword">char</span> *fileUser = getpwuid(st.st_uid)-&gt;pw_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件所在组</span></span><br><span class="line">    <span class="keyword">char</span> *fileGrp = getgrgid(st.st_gid)-&gt;gr_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件大小</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> fileSize = st.st_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取修改的时间，将秒数转化为时间</span></span><br><span class="line">    <span class="keyword">char</span> *time = ctime(&amp;st.st_mtime);</span><br><span class="line">    time[<span class="built_in">strlen</span>(time) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 去掉最后的换行符</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %d %s %s %ld %s %s\n&quot;</span>, perms, linkNum, fileUser, fileGrp, fileSize,</span><br><span class="line">           time, filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后的结果如下，大体上是一样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜  nowcoker ./ls         </span><br><span class="line">_rw-r--r-- 1 ceyewan ceyewan 3738 Sun Jun 19 13:49:26 2022 b.c</span><br><span class="line">drwxr-xr-x 2 ceyewan ceyewan 4096 Sat Jun 18 16:46:47 2022 gdb</span><br><span class="line">drwxr-xr-x 5 ceyewan ceyewan 4096 Sat Jun 18 15:57:27 2022 calculate</span><br><span class="line">_rw-r--r-- 1 ceyewan ceyewan 2478 Sun Jun 19 14:13:59 2022 a.c</span><br><span class="line">_rwxr-xr-x 1 ceyewan ceyewan 16640 Sun Jun 19 14:14:01 2022 ls</span><br><span class="line">drwxr-xr-x 2 ceyewan ceyewan 4096 Sat Jun 18 22:14:31 2022 .vscode</span><br><span class="line">_rwxr-xr-x 1 ceyewan ceyewan 16544 Sun Jun 19 14:00:31 2022 a.out</span><br><span class="line">➜  nowcoker ls -l</span><br><span class="line">总用量 56</span><br><span class="line">-rw-r--r-- 1 ceyewan ceyewan  2478  6月 19 14:13 a.c</span><br><span class="line">-rwxr-xr-x 1 ceyewan ceyewan 16544  6月 19 14:00 a.out</span><br><span class="line">-rw-r--r-- 1 ceyewan ceyewan  3738  6月 19 13:49 b.c</span><br><span class="line">drwxr-xr-x 5 ceyewan ceyewan  4096  6月 18 15:57 calculate</span><br><span class="line">drwxr-xr-x 2 ceyewan ceyewan  4096  6月 18 16:46 gdb</span><br><span class="line">-rwxr-xr-x 1 ceyewan ceyewan 16640  6月 19 14:14 ls</span><br></pre></td></tr></table></figure>

<h1 id="Linux多进程"><a href="#Linux多进程" class="headerlink" title="Linux多进程"></a>Linux多进程</h1><h2 id="进程概述"><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h2><p>程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程： </p>
<p>◼ 二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息来解释文件中的其他信息。（ELF可执行连接格式） </p>
<p>◼ 机器语言指令：对程序算法进行编码。 </p>
<p>◼ 程序入口地址：标识程序开始执行时的起始指令位置。 </p>
<p>◼ 数据：程序文件包含的变量初始值和程序使用的字面量值（比如字符串）。 </p>
<p>◼ 符号表及重定位表：描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试 和运行时的符号解析（动态链接）。 </p>
<p>◼ 共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以 及加载共享库的动态连接器的路径名。 </p>
<p>◼ 其他信息：程序文件还包含许多其他信息，用以描述如何创建进程。</p>
<p>◼ 进程是正在运行的程序的实例。是一个具有一定独立功能的程序关于某个数据集合的 一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。 </p>
<p>◼ 可以用一个程序来创建多个进程，进程是由内核定义的抽象实体，并为该实体分配用 以执行程序的各项系统资源。从内核的角度看，进程由用户内存空间和一系列内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。记录在内核数据结构中的信息包括许多与进程相关的标识号（IDs）、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。 </p>
<p>◼ 单道程序，即在计算机内存中只允许一个的程序运行。 </p>
<p>◼ 多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，相互穿插运行，两个或两个以上程序在计算机系统中同处于开始到结束之间的状态, 这些程序共享计算机系统资源。引入多道程序设计技术的根本目的是为了提高 CPU 的利用率。 </p>
<p>◼ 对于一个单 CPU 系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始运行，但就微观而言，任意时刻，CPU 上运行的程序只有一个。 </p>
<p>◼ 在多道程序设计模型中，多个进程轮流使用 CPU。而当下常见 CPU 为纳秒级，1秒可以执行大约 10 亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。 </p>
<p>◼ 时间片（timeslice）又称为“量子（quantum）”或“处理器片（processor slice）” 是操作系统分配给每个正在运行的进程微观上的一段 CPU 时间。事实上，虽然一台计算机通常可能有多个 CPU，但是同一个 CPU 永远不可能真正地同时运行多个任务。在只考虑一个 CPU 的情况下，这些进程“看起来像”同时运行的，实则是轮番穿插地运行， 由于时间片通常很短（在 Linux 上为 5ms－800ms），用户不会感觉到。 </p>
<p>◼ 时间片由操作系统内核的调度程序分配给每个进程。首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应的时间，当所有进程都处于时间片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复。 </p>
<p>◼ 并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。 </p>
<p>◼ 并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的， 只是把时间分成若干段，使多个进程快速交替的执行。</p>
<p>为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。内核为每个进程分配一个 PCB(Processing Control Block)进程控制块，维护进程相关的信息， Linux 内核的进程控制块是 task_struct 结构体。 </p>
<p>◼ 在 /usr/src/linux-headers-xxx/include/linux/sched.h 文件中可以查 看 struct task_struct 结构体定义。其内部成员有很多，我们只需要掌握以下 部分即可： </p>
<p>⚫ 进程id：系统中每个进程有唯一的 id，用 pid_t 类型表示，其实就是一个非负整数 </p>
<p>⚫ 进程的状态：有就绪、运行、挂起、停止等状态 </p>
<p>⚫ 进程切换时需要保存和恢复的一些CPU寄存器 </p>
<p>⚫ 描述虚拟地址空间的信息 </p>
<p>⚫ 描述控制终端的信息 </p>
<p>⚫ 当前工作目录（Current Working Directory） </p>
<p>⚫ umask 掩码 </p>
<p>⚫ 文件描述符表，包含很多指向 file 结构体的指针 </p>
<p>⚫ 和信号相关的信息 </p>
<p>⚫ 用户 id 和组 id </p>
<p>⚫ 会话（Session）和进程组 </p>
<p>⚫ 进程可以使用的资源上限（Resource Limit）</p>
<h2 id="进程状态转换"><a href="#进程状态转换" class="headerlink" title="进程状态转换"></a>进程状态转换</h2><p>进程状态反映进程执行过程的变化。这些状态随着进程的执行和外界条件的变化而转换。 </p>
<p>在三态模型中，进程状态分为三个基本状态，即就绪态，运行态，阻塞态。</p>
<p>在五态模型 中，进程分为新建态、就绪态，运行态，阻塞态，终止态。 </p>
<p>◼ 运行态：进程占有处理器正在运行 </p>
<p>◼ 就绪态：进程具备运行条件，等待系统分配处理器以便运行。当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行。在一个系统中处于就绪状态的进 程可能有多个，通常将它们排成一个队列，称为就绪队列 </p>
<p>◼ 阻塞态：又称为等待(wait)态或睡眠(sleep)态，指进程 不具备运行条件，正在等待某个事件的完成</p>
<p><img src="Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8.assets/image-20220701155036236.png" alt="image-20220701155036236"></p>
<p><img src="Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8.assets/image-20220701155128713.png" alt="image-20220701155128713"></p>
<p>◼ 新建态：进程刚被创建时的状态，尚未进入就绪队列 </p>
<p>◼ 终止态：进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。进入终止态的进程以后不再执行，但依然保留在操作系 统中等待善后。一旦其他进程完成了对终止态进程的信息抽取之后，操作系统将删除该进程。</p>
<h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看进程</span></span><br><span class="line">ps aux / ajx</span><br><span class="line"><span class="meta">#</span><span class="bash"> a：显示终端上的所有进程，包括其他用户的进程</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> u：显示进程的详细信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> x：显示没有控制终端的进程</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> j：列出与作业控制相关的信息</span></span><br></pre></td></tr></table></figure>

<h2 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看文件信息</span></span><br><span class="line">stat filename</span><br><span class="line"><span class="meta">#</span><span class="bash"> STAT参数意义：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> D 不可中断 Uninterruptible（usually IO）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> R 正在运行，或在队列中的进程</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> S(大写) 处于休眠状态</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> T 停止或被追踪</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Z 僵尸进程</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> W 进入内存交换（从内核2.6开始无效）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> X 死掉的进程</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> &lt; 高优先级</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> N 低优先级</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> s 包含子进程</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> + 位于前台的进程组</span></span><br></pre></td></tr></table></figure>

<h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 实时显示进程动态</span></span><br><span class="line">top [-d second] </span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以在使用 top 命令时加上 -d 来指定显示信息更新的时间间隔，在 top 命令执行后，可以按以下按键对显示的结果进行排序：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> M 根据内存使用量排序</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> P 根据 CPU 占有率排序</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> T 根据进程运行时间长短排序</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> U 根据用户名来筛选进程</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> K 输入指定的 PID 杀死进程</span></span><br></pre></td></tr></table></figure>

<h2 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kill [-signal] pid</span><br><span class="line">kill –l 																		#列出所有信号</span><br><span class="line">kill –SIGKILL 进程ID</span><br><span class="line">kill -9 进程ID																</span><br><span class="line">killall name 																	#根据进程名杀死进程</span><br><span class="line"></span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS     </span><br></pre></td></tr></table></figure>

<p>每个进程都由进程号来标识，其类型为 pid_t（整型），进程号的范围：0～32767。 </p>
<p>进程号总是唯一的，但可以重用。当一个进程终止后，其进程号就可以再次使用。 </p>
<p>◼ 任何进程（除 init 进程）都是由另一个进程创建，该进程称为被创建进程的父进程， 对应的进程号称为父进程号（PPID）。</p>
<p>◼ 进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各 种信号，关联的进程有一个进程组号（PGID）。默认情况下，当前的进程号会当做当 前的进程组号。 </p>
<p>◼ 进程号和进程组相关函数： </p>
<h2 id="getpid-getppid-getpgid"><a href="#getpid-getppid-getpgid" class="headerlink" title="getpid getppid getpgid"></a>getpid getppid getpgid</h2><p>⚫ pid_t getpid(void); </p>
<p>⚫ pid_t getppid(void); </p>
<p>⚫ pid_t getpgid(pid_t pid);</p>
<h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成 进程树结构模型。 </p>
<p>#include  #include  pid_t fork(void); </p>
<p>返回值： </p>
<p>⚫ 成功：子进程中返回 0，父进程中返回子进程 ID </p>
<p>⚫ 失败：返回 -1 </p>
<p>失败的两个主要原因： </p>
<ol>
<li>  当前系统的进程数已经达到了系统规定的上限，这时 errno 的值被设置 为 EAGAIN </li>
<li>  系统内存不足，这时 errno 的值被设置为 ENOMEM</li>
</ol>
<p><strong>tips</strong></p>
<p>实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (copy- on-write) 实现。</p>
<p>写时拷贝是一种可以推迟甚至避免拷贝数据的技术。</p>
<p>内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。</p>
<p>只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。</p>
<p>也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。</p>
<p>注意：fork之后父子进程共享文件，</p>
<p>fork产生的子进程与父进程相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。</p>
<h2 id="虚拟地址空间-1"><a href="#虚拟地址空间-1" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h2><p><img src="Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8.assets/image-20220701161525995.png" alt="image-20220701161525995"></p>
<h2 id="GDB-多进程调试"><a href="#GDB-多进程调试" class="headerlink" title="GDB 多进程调试"></a>GDB 多进程调试</h2><p>使用 GDB 调试的时候，GDB 默认只能跟踪一个进程</p>
<p>可以在 fork 函数调用之前，通过指令设置 GDB 调试工具跟踪父进程或者是跟踪子进程，默认跟踪父进程。 </p>
<p>设置调试父进程或者子进程：<strong>set follow-fork-mode [parent（默认）| child]</strong> </p>
<p>设置调试模式：<strong>set detach-on-fork [on(默认) | off]</strong> ，</p>
<p>on表示调试当前进程的时候，其它的进程继续运行</p>
<p>off调试当前进程的时候，其它进程被 GDB 挂起。 </p>
<p>查看调试的进程：<strong>info inferiors</strong> </p>
<p>切换当前调试的进程：<strong>inferior id</strong> </p>
<p>使进程脱离 GDB 调试：<strong>detach inferiors id</strong></p>
<h2 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h2><p>exec 函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。 </p>
<p>exec 函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程 ID 等一些表面上的信息仍保持原样， 颇有些神似“三十六计”中的“金蝉脱壳”。</p>
<p><strong>看上去还是旧的躯壳，却已经注入了新的灵魂</strong>。</p>
<p>只有调用失败了，它们才会返回 -1，从原程序的调用点接着往下执行。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int execl(const char *path, const char *arg, .../* (char *) NULL */);</span><br><span class="line">int execlp(const char *file, const char *arg, ... /* (char *) NULL */);</span><br><span class="line">int execle(const char *path, const char *arg, .../*, (char *) NULL, char * const envp[] */);</span><br><span class="line">int execv(const char *path, char *const argv[]);</span><br><span class="line">int execvp(const char *file, char *const argv[]);</span><br><span class="line">int execvpe(const char *file, char *const argv[], char *const envp[]);</span><br><span class="line">int execve(const char *filename, char *const argv[], char *const envp[]);</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> l(list) 参数地址列表，以空指针结尾</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> v(vector) 存有各参数地址的指针数组的地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> p(path) 按 PATH 环境变量指定的目录搜索可执行文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> e(environment) 存有环境变量字符串地址的指针数组的地址</span></span><br></pre></td></tr></table></figure>

<h2 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h2><p><img src="Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8.assets/image-20220701163930201.png" alt="image-20220701163930201"></p>
<h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><p>◼ 父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为孤儿进程 （Orphan Process）。 </p>
<p>◼ 每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init ，而 init  进程会循环地 wait() 它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束 了其生命周期的时候，init 进程就会代表党和政府出面处理它的一切善后工作。</p>
<p>◼ 因此孤儿进程并不会有什么危害。</p>
<h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><p>◼ 每个进程结束之后, 都会释放自己地址空间中的用户区数据，内核区的 PCB 没有办法 自己释放掉，需要父进程去释放。 </p>
<p>◼ 进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸 （Zombie）进程。 </p>
<p>◼ 僵尸进程不能被 kill -9 杀死，这样就会导致一个问题，如果父进程不调用 wait()  或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用， 但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进 程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免。</p>
<h2 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h2><p>◼ 在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要主要指进程控制块PCB的信息 （包括进程号、退出状态、运行时间等）。 </p>
<p>◼ 父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。 </p>
<p>◼ wait() 和 waitpid() 函数的功能一样，区别在于，wait() 函数会阻塞， waitpid() 可以设置不阻塞，waitpid() 还可以指定等待哪个子进程结束。 </p>
<p>◼ 注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">◼ WIFEXITED(status) 非0，进程正常退出</span><br><span class="line">◼ WEXITSTATUS(status) 如果上宏为真，获取进程退出的状态（exit的参数）</span><br><span class="line">◼ WIFSIGNALED(status) 非0，进程异常终止</span><br><span class="line">◼ WTERMSIG(status) 如果上宏为真，获取使进程终止的信号编号</span><br><span class="line">◼ WIFSTOPPED(status) 非0，进程处于暂停状态</span><br><span class="line">◼ WSTOPSIG(status) 如果上宏为真，获取使进程暂停的信号的编号</span><br><span class="line">◼ WIFCONTINUED(status) 非0，进程暂停后已经继续运行</span><br></pre></td></tr></table></figure>

<h2 id="进程间通讯"><a href="#进程间通讯" class="headerlink" title="进程间通讯"></a>进程间通讯</h2><p>◼ 进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间 的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。 </p>
<p>◼ 但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程 间通信( IPC：Inter Processes Communication )。</p>
<p>◼ 进程间通信的目的： </p>
<p>◼ 数据传输：一个进程需要将它的数据发送给另一个进程。 </p>
<p>◼ 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种 事件（如进程终止时要通知父进程）。 </p>
<p>◼ 资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同 步机制。 </p>
<p>◼ 进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制 进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</p>
<p><img src="Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8.assets/image-20220701164447698.png" alt="image-20220701164447698"></p>
<h2 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h2><p>◼ 管道也叫无名（匿名）管道，它是是 UNIX 系统 IPC（进程间通信）的最古老形式， 所有的 UNIX 系统都支持这种通信机制。 </p>
<p>◼ 统计一个目录中文件的数目命令：ls | wc –l，为了执行该命令，shell 创建了两 个进程来分别执行 ls 和 wc。</p>
<p><img src="Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8.assets/image-20220701164634814-16566651963361.png" alt="image-20220701164634814"></p>
<p>◼ 管道其实是一个在内核内存中维护的缓冲器，这个缓冲器的存储能力是有限的，不同的 操作系统大小不一定相同。 </p>
<p>◼ 管道拥有文件的特质：读操作、写操作，匿名管道没有文件实体，有名管道有文件实体， 但不存储数据。可以按照操作文件的方式对管道进行操作。 </p>
<p>◼ 一个管道是一个字节流，使用管道时不存在消息或者消息边界的概念，从管道读取数据 的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少。 </p>
<p>◼ 通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺 序是完全一样的。</p>
<p>◼ 在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，管道是半双工的。 ◼ 从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写 更多的数据，在管道中无法使用 lseek() 来随机的访问数据。 ◼ 匿名管道只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘 关系）之间使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建匿名管道</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="comment">//查看管道缓冲大小命令</span></span><br><span class="line">ulimit –a</span><br><span class="line"><span class="comment">//查看管道缓冲大小函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fpathconf</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> name)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h2><p>◼ 匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提 出了有名管道（FIFO），也叫命名管道、FIFO文件。 </p>
<p>◼ 有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联，以 FIFO  的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样 即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此 通过 FIFO 相互通信，因此，通过 FIFO 不相关的进程也能交换数据。 </p>
<p>◼ 一旦打开了 FIFO，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的 I/O系统调用了（如read()、write()和close()）。与管道一样，FIFO 也有一 个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的。FIFO 的 名称也由此而来：先入先出。</p>
<p>◼ 有名管道（FIFO)和匿名管道（pipe）有一些特点是相同的，不一样的地方在于： </p>
<p>FIFO 在文件系统中作为一个特殊文件存在，但 FIFO 中的内容却存放在内存中。 </p>
<p>当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用。 </p>
<p>FIFO 有名字，不相关的进程可以通过打开有名管道进行通信</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过命令创建有名管道</span></span><br><span class="line">mkfifo 名字</span><br><span class="line"><span class="comment">//通过函数创建有名管道</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一旦使用 mkfifo 创建了一个 FIFO，就可以使用 open 打开它，常见的文件</span></span><br><span class="line"><span class="comment">I/O 函数都可用于 fifo。如：close、read、write、unlink 等。</span></span><br><span class="line"><span class="comment">FIFO 严格遵循先进先出（First in First out），对管道及 FIFO 的读总是</span></span><br><span class="line"><span class="comment">从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如 lseek() </span></span><br><span class="line"><span class="comment">等文件定位操作。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>内存映射（Memory-mapped I/O）是将磁盘文件的数据映射到内存，用户通过修改 内存就能修改磁盘文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags,  <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<p>1.如果对mmap的返回值(ptr)做++操作(ptr++), munmap是否能够成功?<br>void * ptr = mmap(…);<br>ptr++;  可以对其进行++操作<br>munmap(ptr, len);   // 错误,要保存地址</p>
<p>2.如果open时O_RDONLY, mmap时prot参数指定PROT_READ | PROT_WRITE会怎样?<br>错误，返回MAP_FAILED<br>open()函数中的权限建议和prot参数的权限保持一致。</p>
<p>3.如果文件偏移量为1000会怎样?<br>偏移量必须是4K的整数倍，返回MAP_FAILED</p>
<p>4.mmap什么情况下会调用失败?<br>    - 第二个参数：length = 0<br>    - 第三个参数：prot<br>        - 只指定了写权限<br>        - prot PROT_READ | PROT_WRITE<br>          第5个参数fd 通过open函数时指定的 O_RDONLY / O_WRONLY</p>
<p>5.可以open的时候O_CREAT一个新文件来创建映射区吗?<br>    - 可以的，但是创建的文件的大小如果为0的话，肯定不行<br>    - 可以对新的文件进行扩展<br>        - lseek()<br>        - truncate()</p>
<p>6.mmap后关闭文件描述符，对mmap映射有没有影响？<br>    int fd = open(“XXX”);<br>    mmap(,,,,fd,0);<br>    close(fd);<br>    映射区还存在，创建映射区的fd被关闭，没有任何影响。</p>
<p>7.对ptr越界操作会怎样？<br>void * ptr = mmap(NULL, 100,,,,,);<br>4K<br>越界操作操作的是非法的内存 -&gt; 段错误</p>
<h1 id="Linux多线程"><a href="#Linux多线程" class="headerlink" title="Linux多线程"></a>Linux多线程</h1><h1 id="Linux网络编程"><a href="#Linux网络编程" class="headerlink" title="Linux网络编程"></a>Linux网络编程</h1><h2 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h2><p>端口复用最常用的用途是: </p>
<p>​    -防止服务器重启时之前绑定的端口还未释放<br>​    -程序突然退出而系统没有释放端口</p>
<p>常看网络相关信息的命令<br>netstat<br>    参数:<br>        -a        所有的socket<br>        -p        显示正在使用socket的程序的名称<br>        -n        直接使用IP地址，而不通过域名服务器</p>
<h3 id="epoll-oneshot"><a href="#epoll-oneshot" class="headerlink" title="epoll oneshot"></a>epoll oneshot</h3><p>EPOLL_ONESHOT既可以在et下也可以在lt下设置。效果是一样的，都是同一个fd上面的相同事件只会触发一次。如果设置了EPOLL_ONESHOT，也是需要把数据读完，然后重置event。而不能像原始lt编程方式那样依赖于事件通知来读取数据了。</p>
<p><del>在ep_send_events_proc()中，会检查epitem是不是oneshot模式的，如果是的，第一次唤醒还是正常处理的，但是会将epitem中监听的事件选项清0,那么后续唤醒的时候，执行ep_item_poll()获取监听事件的时候，就获取的是空事件的。即确保了该监听项的oneshot。</del></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shallowshades.github.io.git/2022/06/22/Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/" data-id="clca7m48h000ixog0hgzk8yat" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-net" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/06/22/net/" class="article-date">
  <time datetime="2022-06-22T03:41:05.000Z" itemprop="datePublished">2022-06-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/06/22/net/">net</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Get和Post一般的区别"><a href="#Get和Post一般的区别" class="headerlink" title="Get和Post一般的区别"></a>Get和Post一般的区别</h2><p>（1）post更安全（不会作为url的一部分，不会被缓存、保存在服务器日志、以及浏览器浏览记录中）<br>（2）post发送的数据更大（get有url长度限制）<br>（3）post能发送更多的数据类型（get只能发送ASCII字符）<br>（4）post比get慢<br>（5）post用于修改和写入数据，get一般用于搜索排序和筛选之类的操作（淘宝，支付宝的搜索查询都是get提交），目的是资源的获取，读取数据<br>虽然在开发中经常用get或者post请求，但是由于我们资历经验的欠缺，或许就重来没有深究过什么场合用get请求，什么场合用post请求，我相信不止我一个人当看到第4,5条的时候，就会明白为什么面试官对我们的回答不满意，也明白了自己对get或post用法理解的欠缺，那么get比post更快，究竟快多少呢？表现在那些方面？</p>
<p>为什么get比post更快</p>
<p><strong>1.post请求包含更多的请求头</strong><br>因为post需要在请求的body部分包含数据，所以会多了几个数据描述部分的首部字段（如：content-type）,这其实是微乎其微的。</p>
<p><strong>2.最重要的一条，post在真正接收数据之前会先将请求头发送给服务器进行确认，然后才真正发送数据</strong><br>post请求的过程：<br>（1）浏览器请求tcp连接（第一次握手）<br>（2）服务器答应进行tcp连接（第二次握手）<br>（3）浏览器确认，并发送post请求头（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送）<br>（4）服务器返回100 Continue响应<br>（5）浏览器发送数据<br>（6）服务器返回200 OK响应<br>get请求的过程：<br>（1）浏览器请求tcp连接（第一次握手）<br>（2）服务器答应进行tcp连接（第二次握手）<br>（3）浏览器确认，并发送get请求头和数据（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送）<br>（4）服务器返回200 OK响应<br>也就是说，目测get的总耗是post的2/3左右，这个口说无凭，网上已经有网友进行过测试。</p>
<p><strong>3.get会将数据缓存起来，而post不会</strong><br>可以做个简短的测试，使用ajax采用get方式请求静态数据（比如html页面，图片）的时候，如果两次传输的数据相同，第二次以后消耗的时间将会在10ms以内（chrome测试），而post每次消耗的时间都差不多。经测试，chrome和firefox下如果检测到get请求的是静态资源，则会缓存，如果是数据，则不会缓存，但是IE什么都会缓存起来，当然，应该没有人用post去获取静态数据吧，反正我是没见过。</p>
<h2 id="一个TCP连接可以发送多少个HTTP请求？"><a href="#一个TCP连接可以发送多少个HTTP请求？" class="headerlink" title="一个TCP连接可以发送多少个HTTP请求？"></a>一个TCP连接可以发送多少个HTTP请求？</h2><p>TCP与HTTP的渊源<br>TCP协议对应于传输层，HTTP协议对应于应用层。WEB项目中，HTTP协议是建立在TCP的基础上的。</p>
<p>最初浏览器从服务器加载一个网页，会发起一个HTTP请求，这时需要先建立一个TCP连接。当本次数据请求完毕之后，会立刻断开TCP连接。</p>
<p>但随着时间的推理，HTML网页内容越来越复杂，不仅有内容，还有JS、CSS和图片资源，每个资源的请求都建立一次TCP连接，效率就会很低。</p>
<p>这时，Keep-Alive就被提出用来了，专门用于解决效率低的问题。</p>
<p>本文关于TCP连接能够发送多少个HTTP请求，本质上就是围绕着解决通信的低效问题的。</p>
<p><strong>问题一：浏览器建立TCP连接之后，完成一次HTTP请求，是否会断开？</strong><br>HTTP协议Header中的Connection属性决定了连接是否持久，不同HTTP协议版本有所不同。</p>
<p>HTTP/1.0中Connection默认为close，即每次请求都会重新建立和断开TCP连接。缺点：建立和断开TCP连接，代价过大。</p>
<p>HTTP/1.1中Connection默认为keep-alive，即连接可以复用，不用每次都重新建立和断开TCP连接。超时之后没有连接则主动断开。可以通过声明Connection为close进行关闭。</p>
<p>优点：TCP连接可被重复利用，减少建立连接的损耗，SSL的开销也可以避免。刷新页面时也可以复用，从而不再建立SSL连接等。</p>
<p>结论：默认情况下（HTTP/1.1）建立TCP连接不会断开，只有在请求报头中声明Connection: close才会请求完成之后关闭连接。不断开的最终目的是减少建立连接所导致的性能损耗。</p>
<p><strong>问题二：一个TCP连接可以对应几个HTTP请求？</strong><br>如果Connection为close，则一个TCP连接只对应一个HTTP请求。</p>
<p>如果Connection为Keep-alive，则一个TCP连接可对应一个到多个HTTP请求。</p>
<p><strong>问题三：一个TCP连接中，可以同时发送多个HTTP请求吗？</strong><br>HTTP/1.1中单个TCP连接在同一时刻只能处理一个请求。HTTP/1.1在RFC 2616中规定了Pipelining来解决这个问题，但浏览器默认是关闭的。</p>
<p>RFC 2616中规定：一个支持持久连接的客户端可以在一个连接中发送多个请求（不需要等待任意请求的响应）。收到请求的服务器必须按照请求收到的顺序发送响应。</p>
<p>Pipelining本身存在一些问题，比如代理服务器不能正确处理HTTP Pipelining、Head-of-line Blocking连接头阻塞（首个请求耗时过长，阻塞其他请求）。所以，浏览器默认关闭该功能。</p>
<p>HTTP/2.0提供了多路复用技术Multiplexing，一个TCP可以并发多个HTTP请求（理论无上限，但是一般浏览器会有TCP并发数的限制）。</p>
<p>HTTP/1.1中为了提升性能，通常会采用连接复用和同时建立多个TCP连接的方式提升性能。</p>
<p>结论：HTTP/1.1中存在Pipelining技术支持一个连接发送多个请求，但存在弊端，浏览器默认关闭。HTTP/2.0中通过多路复用技术支持一个TCP连接中并发请求HTTP。</p>
<p><strong>问题四：浏览器对同一Host建立TCP连接的数量有没限制？</strong><br>不同浏览器限制不同，比如Chrome最多允许同一个Host可建立6个TCP连接。</p>
<p>如果服务器只支持HTTP/1.1，浏览器会采用在同一个Host下建立多个TCP连接来进行效率提升。如果是基于HTTPS传输，在SSL握手之后，还会尝试协商是否可以采用HTTP/2.0的Multiplexing功能。</p>
<p><strong>问题五：keep-alive使用场景及优缺点</strong><br>开启keep-alive对内存要求高，关闭keep-alive对CPU要求高；如果内存和CPU都足够，开启和关闭keep-alive对性能影响不大；如果考虑服务器压力，如果是静态页面，大量的调用js或者图片的话，建议开启keep-alive；如果是动态网页，建议关闭keep-alive。</p>
<p>注意事项：如果需要使用keep-alive功能，服务器端如果使用nginx中keepalive_timeout值要大于0。</p>
<p>小结<br>通过上面的整体分析，我们不仅了解了TCP与HTTP之间的关系，还明确了现代浏览器基于不同的HTTP协议所作出的网络层面优化。而HTTP2/0的多路复用机制还是一些高性能框架的基础，比如gRPC的实现。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shallowshades.github.io.git/2022/06/22/net/" data-id="clca7m48o0012xog0auez8lj5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/net/" rel="tag">net</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-排序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/06/22/%E6%8E%92%E5%BA%8F/" class="article-date">
  <time datetime="2022-06-22T03:41:05.000Z" itemprop="datePublished">2022-06-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/06/22/%E6%8E%92%E5%BA%8F/">排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h1><p>在内存上进行的排序</p>
<h2 id="直接插入排序（插入排序）"><a href="#直接插入排序（插入排序）" class="headerlink" title="直接插入排序（插入排序）"></a>直接插入排序（插入排序）</h2><p>空间复杂度：O(1) 原地排序</p>
<p>时间复杂度：O(n^2)</p>
<p>稳定</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(T A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt; A[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            T tmp = A[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; tmp &lt; A[j]; --j) &#123;</span><br><span class="line">                A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">            &#125;</span><br><span class="line">            A[j + <span class="number">1</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="折半插入排序（插入排序）"><a href="#折半插入排序（插入排序）" class="headerlink" title="折半插入排序（插入排序）"></a>折半插入排序（插入排序）</h2><p>对直接插入排序的优化,减少了比较的次数</p>
<p>但是未改变还是要移动元素的本质，时间复杂度还是O(n^2)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(T A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low, high, mid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt; A[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            T tmp = A[i];</span><br><span class="line">            low = <span class="number">0</span>, high = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">                mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (A[mid] &gt; tmp) high = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= high + <span class="number">1</span>; --j) &#123;</span><br><span class="line">                A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">            &#125;</span><br><span class="line">            A[high + <span class="number">1</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="希尔排序（插入排序）"><a href="#希尔排序（插入排序）" class="headerlink" title="希尔排序（插入排序）"></a>希尔排序（插入排序）</h2><p>空间复杂度：O(1)</p>
<p>时间复杂度：O(n^1.3)~O(n^2)</p>
<p>不稳定</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(T A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> dk = n / <span class="number">2</span>; dk &gt; <span class="number">0</span>; dk /= <span class="number">2</span>) &#123;<span class="comment">//步长</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = dk; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &lt; A[i - dk]) &#123;<span class="comment">//将A[i]插入有序增量子表</span></span><br><span class="line">                T tmp = A[i];</span><br><span class="line">                <span class="keyword">for</span> (j = i - dk; j &gt;= <span class="number">0</span> &amp;&amp; tmp &lt; A[j]; j -= dk) &#123;<span class="comment">//记录后移</span></span><br><span class="line">                    A[j + dk] = A[j];</span><br><span class="line">                &#125;</span><br><span class="line">                A[j + dk] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="冒泡排序（交换排序）"><a href="#冒泡排序（交换排序）" class="headerlink" title="冒泡排序（交换排序）"></a>冒泡排序（交换排序）</h2><p>空间复杂度：O(1)</p>
<p>时间复杂度：O(n^2)</p>
<p>稳定</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(T A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt; A[j]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(A[i], A[j]);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(A);</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速排序（交换排序）"><a href="#快速排序（交换排序）" class="headerlink" title="快速排序（交换排序）"></a>快速排序（交换排序）</h2><p>时间复杂度：O(nlog2n) 最坏O(n^2) 极端情况，每次划分区间为[0,0],[1,n-1]</p>
<p>空间复杂度：栈深度O(log2n) 最坏O(n),和上述极端情况相同</p>
<p>稳定性：不稳定</p>
<p>避免出现极端的方法：随机选取，头尾中间取中间值</p>
<p><strong>平均性能最优</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T A[], <span class="keyword">int</span> n = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; A[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(T A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    T pivot = A[low];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; A[high] &gt;= pivot) --high;</span><br><span class="line">        A[low] = A[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot) ++low;</span><br><span class="line">        A[high] = A[low];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A[low] = pivot;</span><br><span class="line">    <span class="comment">//print(A);</span></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(T A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> pivotpos = <span class="built_in">Partition</span>(A, low, high);</span><br><span class="line">        <span class="built_in">QuickSort</span>(A, low, pivotpos - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(A, pivotpos + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123; <span class="number">19</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>,<span class="number">13</span>,<span class="number">27</span>,<span class="number">49</span> ,<span class="number">43</span>,<span class="number">34</span> &#125;;</span><br><span class="line">    QuickSort&lt;<span class="keyword">int</span>&gt;(a, <span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="简单选择排序（选择排序）"><a href="#简单选择排序（选择排序）" class="headerlink" title="简单选择排序（选择排序）"></a>简单选择排序（选择排序）</h2><p>空间复杂度：O(1)</p>
<p>时间复杂度：O(n^2)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(T A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[j] &lt; A[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minIndex != i) <span class="built_in">swap</span>(A[i], A[minIndex]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆排序（选择排序）"><a href="#堆排序（选择排序）" class="headerlink" title="堆排序（选择排序）"></a>堆排序（选择排序）</h2><p>完全二叉树 可用一维数组</p>
<p>空间复杂度 ：O(1)</p>
<p>时间复杂度 ：O(nlog2n)   建堆O(n) 调整O(log2n)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A[1]为第一个元素</span></span><br><span class="line"><span class="comment">//调整</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(T A[], <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * k; i &lt;= n; i *= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; n &amp;&amp; (A[i] &gt; A[k] || A[i + <span class="number">1</span>] &gt; A[k])) &#123;<span class="comment">//有两个子节点</span></span><br><span class="line">			<span class="keyword">if</span> (A[i] &gt; A[i + <span class="number">1</span>]) <span class="built_in">swap</span>(A[i], A[k]);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">swap</span>(A[++i], A[k]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (A[i] &gt; A[k]) &#123;<span class="comment">//只有一个子节点</span></span><br><span class="line">			<span class="built_in">swap</span>(A[i], A[k]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;<span class="comment">//已满足堆结构</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		k = i;<span class="comment">//调整父节点的下标</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建堆</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(T A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="built_in">HeapAdjust</span>(A, i, n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(T A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">BuildMaxHeap</span>(A, n);<span class="comment">//初始化大顶堆</span></span><br><span class="line">	<span class="built_in">print</span>(A, <span class="number">11</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; --i) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(A[i], A[<span class="number">1</span>]);<span class="comment">//输出堆顶元素</span></span><br><span class="line">		<span class="built_in">HeapAdjust</span>(A, <span class="number">1</span>, i - <span class="number">1</span>);<span class="comment">//调整</span></span><br><span class="line">		<span class="built_in">print</span>(A, <span class="number">11</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>2路归并排序算法</p>
<p>空间复杂度：辅助空间O(n)</p>
<p>时间复杂度：O(nlog2n)</p>
<p>稳定性：稳定</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* B; <span class="comment">//辅助数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(T A[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将A[low, high] 复制到B[k]中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = low; k &lt;= high; ++k) B[k] = A[k];</span><br><span class="line">    <span class="comment">//memcpy(B + low, A + low, (high - low + 1) * sizeof(T));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//B数组中的未排序的数据 i[low, mid] j[mid + 1, high] </span></span><br><span class="line">    <span class="comment">//A数组中已排序的数据 k[low, high]</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span> (i = low, j = mid + <span class="number">1</span>, k = low; i &lt;= mid &amp;&amp; j &lt;= high; ++k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (B[i] &lt;= B[j]) &#123;</span><br><span class="line">            A[k] = B[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            A[k] = B[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将未检测完的数据放入A中</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) A[k++] = B[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high) A[k++] = B[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(T A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>; <span class="comment">//从中间划分两个子序列</span></span><br><span class="line">        <span class="built_in">MergeSort</span>(A, low, mid);     <span class="comment">//对左侧的子序列排序</span></span><br><span class="line">        <span class="built_in">MergeSort</span>(A, mid + <span class="number">1</span>, high);<span class="comment">//对右侧的子序列排序</span></span><br><span class="line">        <span class="built_in">Merge</span>(A, low, mid, high);   <span class="comment">//合并</span></span><br><span class="line">        <span class="built_in">print</span>(A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123; <span class="number">19</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>,<span class="number">13</span>,<span class="number">27</span>,<span class="number">49</span> ,<span class="number">43</span>,<span class="number">34</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    B = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    MergeSort&lt;<span class="keyword">int</span>&gt;(a, <span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">delete</span>[] B;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>辅助队列要r个，r为基数 （0，1，… , r - 1）个状态</p>
<p>进行d次分配和收集r^d&gt;=MAX(最大元素),分配为O(n),收集为O(r)(改变指针指向)</p>
<p>时间复杂度：O(d(n+r))</p>
<p>空间复杂度：O(r) r个队头指针和r个队尾指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">v</span>(<span class="number">10</span>, vector&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BaseSort</span><span class="params">(T A[], <span class="keyword">int</span> n, <span class="keyword">int</span> base)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分配</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        v[A[i] / base % <span class="number">10</span>].<span class="built_in">push_back</span>(A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//收集</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            A[k++] = v[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        v[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123; <span class="number">19</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>,<span class="number">13</span>,<span class="number">27</span>,<span class="number">49</span> ,<span class="number">43</span>,<span class="number">34</span> &#125;;</span><br><span class="line">    <span class="comment">//QuickSort&lt;int&gt;(a, 0, 9);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//B = new int[10];</span></span><br><span class="line">    <span class="comment">//MergeSort&lt;int&gt;(a, 0, 9);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1e9</span>; i *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="built_in">BaseSort</span>(a, <span class="number">10</span>, i);</span><br><span class="line">        <span class="built_in">print</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://shallowshades.github.io.git/2022/06/22/%E6%8E%92%E5%BA%8F/" data-id="clca7m48u001mxog09hx2gwgd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DesignMode/" rel="tag">DesignMode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaWeb/" rel="tag">JavaWeb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/database/" rel="tag">database</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/" rel="tag">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/net/" rel="tag">net</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/C/" style="font-size: 20px;">C++</a> <a href="/tags/DesignMode/" style="font-size: 10px;">DesignMode</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/JavaWeb/" style="font-size: 10px;">JavaWeb</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Web/" style="font-size: 10px;">Web</a> <a href="/tags/database/" style="font-size: 15px;">database</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/go/" style="font-size: 10px;">go</a> <a href="/tags/golang/" style="font-size: 10px;">golang</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/net/" style="font-size: 10px;">net</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">十二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/12/13/Linux/">Linux</a>
          </li>
        
          <li>
            <a href="/2022/12/13/Redis/">Redis</a>
          </li>
        
          <li>
            <a href="/2022/12/13/ginchat/">ginchat</a>
          </li>
        
          <li>
            <a href="/2022/12/13/go/">Go</a>
          </li>
        
          <li>
            <a href="/2022/09/08/git/">git</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 未名<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>