<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"shallowshades.github.io.git","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.8.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="安装LinuxMySQL安装步骤Linux的版本为CentOS7； 上传安装包：WinSCP&#x2F;FinalShell 中间会出现多余的依赖和缺少的依赖，根据情况删除或者添加 12345678910111213141516171819202122mkdir mysqltar -xvf mysql-8.0.26-1.el7.x86_64.rpm-bundle.tar -C mysqlcd mysqlrp">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL进阶">
<meta property="og:url" content="https://shallowshades.github.io.git/2022/03/22/MySQL%E8%BF%9B%E9%98%B6/index.html">
<meta property="og:site_name" content="未名的博客">
<meta property="og:description" content="安装LinuxMySQL安装步骤Linux的版本为CentOS7； 上传安装包：WinSCP&#x2F;FinalShell 中间会出现多余的依赖和缺少的依赖，根据情况删除或者添加 12345678910111213141516171819202122mkdir mysqltar -xvf mysql-8.0.26-1.el7.x86_64.rpm-bundle.tar -C mysqlcd mysqlrp">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://shallowshades.github.io.git/2022/03/22/MySQL%E8%BF%9B%E9%98%B6/MySQL.assets/image-20220324214703828.png">
<meta property="og:image" content="https://shallowshades.github.io.git/2022/03/22/MySQL%E8%BF%9B%E9%98%B6/MySQL.assets/image-20220324220814487.png">
<meta property="og:image" content="https://shallowshades.github.io.git/2022/03/22/MySQL%E8%BF%9B%E9%98%B6/MySQL%E8%BF%9B%E9%98%B6.assets/image-20220327162837758-16483697209971.png">
<meta property="og:image" content="https://shallowshades.github.io.git/2022/03/22/MySQL%E8%BF%9B%E9%98%B6/MySQL%E8%BF%9B%E9%98%B6.assets/image-20220327164317614-16483705990532.png">
<meta property="og:image" content="https://shallowshades.github.io.git/2022/03/22/MySQL%E8%BF%9B%E9%98%B6/MySQL%E8%BF%9B%E9%98%B6.assets/image-20220328154033222-16484532353571.png">
<meta property="og:image" content="https://shallowshades.github.io.git/2022/03/22/MySQL%E8%BF%9B%E9%98%B6/MySQL%E8%BF%9B%E9%98%B6.assets/image-20220328154144182-16484533059962.png">
<meta property="og:image" content="https://shallowshades.github.io.git/2022/03/22/MySQL%E8%BF%9B%E9%98%B6/MySQL%E8%BF%9B%E9%98%B6.assets/image-20220329144311774-16485361947552.png">
<meta property="og:image" content="https://shallowshades.github.io.git/2022/03/22/MySQL%E8%BF%9B%E9%98%B6/MySQL%E8%BF%9B%E9%98%B6.assets/image-20220329144728649-16485364500183.png">
<meta property="og:image" content="https://shallowshades.github.io.git/2022/03/22/MySQL%E8%BF%9B%E9%98%B6/MySQL%E8%BF%9B%E9%98%B6.assets/image-20220329151616445-16485381781014.png">
<meta property="og:image" content="https://shallowshades.github.io.git/2022/03/22/MySQL%E8%BF%9B%E9%98%B6/MySQL%E8%BF%9B%E9%98%B6.assets/image-20220329152031679-16485384330165.png">
<meta property="og:image" content="https://shallowshades.github.io.git/2022/03/22/MySQL%E8%BF%9B%E9%98%B6/MySQL%E8%BF%9B%E9%98%B6.assets/image-20220329154501371-16485399028726.png">
<meta property="article:published_time" content="2022-03-22T14:05:47.000Z">
<meta property="article:modified_time" content="2022-12-14T08:13:13.923Z">
<meta property="article:author" content="未名">
<meta property="article:tag" content="database">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://shallowshades.github.io.git/2022/03/22/MySQL%E8%BF%9B%E9%98%B6/MySQL.assets/image-20220324214703828.png">


<link rel="canonical" href="https://shallowshades.github.io.git/2022/03/22/MySQL%E8%BF%9B%E9%98%B6/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://shallowshades.github.io.git/2022/03/22/MySQL%E8%BF%9B%E9%98%B6/","path":"2022/03/22/MySQL进阶/","title":"MySQL进阶"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>MySQL进阶 | 未名的博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">未名的博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">过去链接未来</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">14</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">0</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">48</span></a></li>
        <li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E8%A3%85LinuxMySQL"><span class="nav-number">1.</span> <span class="nav-text">安装LinuxMySQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.1.</span> <span class="nav-text">安装步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8MySQL%E6%9C%8D%E5%8A%A1"><span class="nav-number">1.2.</span> <span class="nav-text">启动MySQL服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5MySQL"><span class="nav-number">1.3.</span> <span class="nav-text">远程连接MySQL</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">2.</span> <span class="nav-text">存储引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.</span> <span class="nav-text">MySQL体系结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AE%80%E4%BB%8B"><span class="nav-number">2.2.</span> <span class="nav-text">存储引擎简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%89%B9%E7%82%B9"><span class="nav-number">2.3.</span> <span class="nav-text">各存储引擎区别及特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95"><span class="nav-number">3.</span> <span class="nav-text">索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E6%A6%82%E8%BF%B0"><span class="nav-number">3.1.</span> <span class="nav-text">索引概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.</span> <span class="nav-text">索引结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="nav-number">3.3.</span> <span class="nav-text">索引分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%AF%AD%E6%B3%95"><span class="nav-number">3.4.</span> <span class="nav-text">索引语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8"><span class="nav-number">3.5.</span> <span class="nav-text">索引使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">3.6.</span> <span class="nav-text">索引设计原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="nav-number">3.7.</span> <span class="nav-text">SQL性能分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E4%BC%98%E5%8C%96"><span class="nav-number">4.</span> <span class="nav-text">SQL优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE"><span class="nav-number">5.</span> <span class="nav-text">视图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">6.</span> <span class="nav-text">存储过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">6.1.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">6.2.</span> <span class="nav-text">流程控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%B8%E6%A0%87"><span class="nav-number">6.3.</span> <span class="nav-text">游标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-number">6.4.</span> <span class="nav-text">条件处理程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0"><span class="nav-number">6.5.</span> <span class="nav-text">存储函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-number">7.</span> <span class="nav-text">触发器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">8.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E9%94%81"><span class="nav-number">8.1.</span> <span class="nav-text">全局锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="nav-number">8.2.</span> <span class="nav-text">表级锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="nav-number">8.3.</span> <span class="nav-text">行级锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB%E5%BC%95%E6%93%8E"><span class="nav-number">9.</span> <span class="nav-text">InnoDB引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">9.1.</span> <span class="nav-text">逻辑存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84"><span class="nav-number">9.2.</span> <span class="nav-text">架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">9.3.</span> <span class="nav-text">内存结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84"><span class="nav-number">9.4.</span> <span class="nav-text">磁盘结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="nav-number">9.5.</span> <span class="nav-text">后台线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86"><span class="nav-number">9.6.</span> <span class="nav-text">事务原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVCC"><span class="nav-number">9.7.</span> <span class="nav-text">MVCC</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E7%AE%A1%E7%90%86"><span class="nav-number">10.</span> <span class="nav-text">MySQL管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">10.1.</span> <span class="nav-text">系统数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="nav-number">10.2.</span> <span class="nav-text">常用工具</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">未名</p>
  <div class="site-description" itemprop="description">大学结束了，大学究竟是什么</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shallowshades.github.io.git/2022/03/22/MySQL%E8%BF%9B%E9%98%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="未名">
      <meta itemprop="description" content="大学结束了，大学究竟是什么">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="未名的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL进阶
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-22 22:05:47" itemprop="dateCreated datePublished" datetime="2022-03-22T22:05:47+08:00">2022-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-14 16:13:13" itemprop="dateModified" datetime="2022-12-14T16:13:13+08:00">2022-12-14</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="安装LinuxMySQL"><a href="#安装LinuxMySQL" class="headerlink" title="安装LinuxMySQL"></a>安装LinuxMySQL</h2><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>Linux的版本为<strong>CentOS7</strong>；</p>
<p>上传安装包：WinSCP/FinalShell</p>
<p>中间会出现多余的依赖和缺少的依赖，根据情况删除或者添加</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mkdir mysql</span><br><span class="line"></span><br><span class="line">tar -xvf mysql-8.0.26-1.el7.x86_64.rpm-bundle.tar -C mysql</span><br><span class="line"></span><br><span class="line">cd mysql</span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-common-8.0.26-1.el7.x86_64.rpm </span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-client-plugins-8.0.26-1.el7.x86_64.rpm </span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-libs-8.0.26-1.el7.x86_64.rpm </span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-libs-compat-8.0.26-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">yum install openssl-devel</span><br><span class="line"></span><br><span class="line">rpm -ivh  mysql-community-devel-8.0.26-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-client-8.0.26-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">rpm -ivh  mysql-community-server-8.0.26-1.el7.x86_64.rpm</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="启动MySQL服务"><a href="#启动MySQL服务" class="headerlink" title="启动MySQL服务"></a>启动MySQL服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">启动</span></span><br><span class="line">systemctl start mysqld</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">重启</span></span><br><span class="line">systemctl restart mysqld</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">停止</span></span><br><span class="line">systemctl stop mysqld</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查询自动生成的root用户密码</span></span><br><span class="line">grep &#x27;temporary password&#x27;/var/log/mysqld.log</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">登录</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">修改密码</span></span><br><span class="line">ALTER  USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123456&#x27;;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">修改密码的校验规则,设置密码的复杂度,0,1,2,数字越小，复杂度越低</span></span><br><span class="line">set global validate_password.policy = 0;</span><br><span class="line"><span class="meta">#</span><span class="bash">设置密码的长度</span></span><br><span class="line">set global validate_password.length = 6;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">默认的root用户只能当前节点localhost访问，无法远程访问，创建一个root账户，用于远程访问</span></span><br><span class="line">create user &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">发放权限</span></span><br><span class="line">grant all on *.* to &#x27;root&#x27;@&#x27;%&#x27;;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">重新登陆</span></span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>

<h3 id="远程连接MySQL"><a href="#远程连接MySQL" class="headerlink" title="远程连接MySQL"></a>远程连接MySQL</h3><p>需要打开防火墙的3306端口</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看防火墙状态</span></span><br><span class="line">firewall-cmd --state</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">关闭防火墙</span></span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">关闭防火墙</span></span><br><span class="line">systemctl disable firewalld.service</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">开启防火墙</span></span><br><span class="line">systemctl start firewalld.service</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">开启端口(需重启防火墙)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> zone --作用域</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> add-port=88/tcp --添加端口,格式为:端口/通讯协议</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> permanent --永久生效,没有此参数重启后失败</span></span><br><span class="line">sudo firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">常用命令</span></span><br><span class="line">firewall-cmd --query-port=3306/tcp				##查询端口是否开放</span><br><span class="line"></span><br><span class="line">firewall-cmd --state 							##查看防火墙状态，是否是running</span><br><span class="line"></span><br><span class="line">firewall-cmd --reload 							##重新载入配置，比如添加规则之后，需要执行此命令</span><br><span class="line"></span><br><span class="line">firewall-cmd --get-zones 						##列出支持的zone</span><br><span class="line"></span><br><span class="line">firewall-cmd --get-services 					##列出支持的服务，在列表中的服务是放行的</span><br><span class="line"></span><br><span class="line">firewall-cmd --query-service ftp 				##查看ftp服务是否支持，返回yes或者no</span><br><span class="line"></span><br><span class="line">firewall-cmd --add-service=ftp 					##临时开放ftp服务</span><br><span class="line"></span><br><span class="line">firewall-cmd --add-service=ftp --permanent 		##永久开放ftp服务</span><br><span class="line"></span><br><span class="line">firewall-cmd --add-port=80/tcp --permanent 		##永久添加80端口</span><br><span class="line"></span><br><span class="line">iptables -L -n 									##查看规则，这个命令是和iptables的相同的</span><br><span class="line"></span><br><span class="line">man firewall-cmd 								##查看帮助</span><br><span class="line"></span><br><span class="line">systemctl status firewalld.service 				##查看防火墙详细状态</span><br></pre></td></tr></table></figure>



<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h3><p><img src="MySQL.assets/image-20220324214703828.png" alt="image-20220324214703828"></p>
<p>1).<strong>连接层</strong></p>
<p>最上层是一些客户端和链接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于 TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p>
<p>2).<strong>服务层</strong></p>
<p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p>
<p>3).<strong>引擎层</strong></p>
<p>存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库中的索引是在存储引擎层实现的。</p>
<p>4).<strong>存储层</strong></p>
<p>数据存储层，主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。</p>
<p>和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，<strong>插件式的存储引擎架构</strong>，将查询处理和其他的系统任务以及数据的存储提取分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p>
<h3 id="存储引擎简介"><a href="#存储引擎简介" class="headerlink" title="存储引擎简介"></a>存储引擎简介</h3><p>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。我们可以在创建表的时候，来指定选择的存储引擎，如果没有指定将自动选择默认的存储引擎。（<strong>MySQL的默认存储引擎是InnoDB</strong>）</p>
<p><strong>建表时指定存储引擎</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">字段<span class="number">1</span> 字段<span class="number">1</span>类型[ COMMENT 字段<span class="number">1</span>注释],</span><br><span class="line">......</span><br><span class="line">字段n 字段n类型[COMMENT 字段n注释]</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB [ COMMENT 表注释];</span><br></pre></td></tr></table></figure>

<p><strong>查询当前数据库支持的存储引擎</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> engines;</span><br></pre></td></tr></table></figure>

<h3 id="各存储引擎区别及特点"><a href="#各存储引擎区别及特点" class="headerlink" title="各存储引擎区别及特点"></a>各存储引擎区别及特点</h3><table>
<thead>
<tr>
<th>特点</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>存储限制</td>
<td>64TB</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>事务安全</td>
<td>支持</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>锁机制</td>
<td>行锁</td>
<td>表锁</td>
<td>表锁</td>
</tr>
<tr>
<td>B+tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Hash索引</td>
<td>-</td>
<td>-</td>
<td>支持</td>
</tr>
<tr>
<td>全文索引</td>
<td>支持(5.6版本之后)</td>
<td>支持</td>
<td>-</td>
</tr>
<tr>
<td>空间使用</td>
<td>高</td>
<td>低</td>
<td>N/A</td>
</tr>
<tr>
<td>内存使用</td>
<td>高</td>
<td>低</td>
<td>中</td>
</tr>
<tr>
<td>批量插入速度</td>
<td>低</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>支持外键</td>
<td>支持</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<p>InnoDB: 是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。</p>
<p>MyISAM ：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</p>
<p>MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。</p>
<p><strong>InnoDB</strong></p>
<p>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的 MySQL 存储引擎。</p>
<p><strong>特点</strong></p>
<p>DML操作遵循ACID模型，支持事务；</p>
<p>行级锁，提高并发访问性能；</p>
<p>支持外键FOREIGN KEY约束，保证数据的完整性和正确性；</p>
<p><strong>文件</strong></p>
<p>xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm-早期的、sdi-新版的）、数据和索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--参数开启，代表对于InnoDB引擎的表，每一张表都对应一个ibd文件</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_file_per_table&#x27;</span>; </span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在文件的位置打开命令行，键入以下命令查看二进制文件xxx.ibd的sdi信息</span></span><br><span class="line">ibd2sdi xxx.ibd</span><br></pre></td></tr></table></figure>

<p><strong>SDI</strong></p>
<p>Serialized Dictionary Information是指表结构元数据。MySQL 8.0通过在元数据发生变化时序列化元数据，提供了崩溃安全性。它的输出是JSON (JavaScript对象表示法)格式，称为序列化字典信息(SDI)。</p>
<p>对于InnoDB表，SDI与InnoDB用户表空间中的数据一起存储。对于MyISAM和其他存储引擎，它被写入数据目录中的.sdi文件。</p>
<p>除了临时表空间和撤销表空间文件外，所有InnoDB表空间文件中都存在SDI。InnoDB表空间文件中的SDI记录仅描述表空间中包含的表和表空间对象。</p>
<ul>
<li>  SDI数据通过对表或检查表的DDL操作进行更新的。</li>
<li>  MySQL服务器使用DDL操作期间访问的内部API来创建和维护SDI记录。</li>
<li>  当MySQL服务器升级到一个新的版本或版本时，SDI数据不会更新。</li>
<li>  记录数据方式：对于InnoDB，一条SDI记录需要一个索引页，默认大小为16KB。但实际SDI数据被压缩以减少存储空间。</li>
<li>  分区表：对于由多个表空间组成的分区InnoDB表，SDI数据存储在第一个分区的表空间文件中。</li>
</ul>
<p>注意，这个SDI只是元数据的备份。它不是元数据本身。数据字典完全存在于InnoDB数据字典表空间中。</p>
<p><strong>SDI文件内容分析</strong></p>
<p>SDI数据的存在提供了元数据冗余。那么，如果数据字典不可用，可以使用ibd2sdi工具直接从InnoDB表空间文件中提取对象元数据。</p>
<p>ibd2sdi是一个用于从InnoDB表空间文件中提取序列化字典信息(SDI)的实用程序,导出格式为JSON。所有的InnoDB表空间文件都存在SDI数据。</p>
<p>ibd2sdi可以</p>
<ul>
<li>  file-per-table 表空间文件上运行(*.ibd files)文件，</li>
<li>  一般表空间文件(*.ibd files)。</li>
<li>  系统表空间文件(ibdata* files)</li>
<li>  数据字典表空间(mysql.ibd)。</li>
<li>  它不支持temporary表空间或undo表空间。</li>
<li>  ibd2sdi可以在运行时使用，也可以在服务器离线时使用。在进行与SDI相关的DDL操作、回滚操作和undo log purge操作时，可能会出现ibd2sdi读取存储在表空间中的SDI数据失败的短时间间隔。</li>
</ul>
<p><strong>逻辑存储结构</strong></p>
<p><img src="MySQL.assets/image-20220324220814487.png" alt="image-20220324220814487"></p>
<p><strong>表空间</strong>: InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以包含多个Segment段。</p>
<p><strong>段</strong>: 表空间是由各个段组成的，常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。</p>
<p><strong>区</strong>: 区是表空间的单元结构，每个区的大小为1M。默认情况下， InnoDB存储引擎页大小为16K，即一个区中一共有64个连续的页。</p>
<p><strong>页</strong>: 页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请4-5 个区。</p>
<p><strong>行</strong>: InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时所指定的字段以外，还包含两个隐藏字段()。</p>
<p><strong>MyISAM</strong></p>
<p>MyISAM是MySQL早期的默认存储引擎。</p>
<p><strong>特点</strong></p>
<p>不支持事务，不支持外键</p>
<p>支持表锁，不支持行锁</p>
<p>访问速度快</p>
<p><strong>文件</strong></p>
<p>xxx.sdi：存储表结构信息</p>
<p>xxx.MYD: 存储数据</p>
<p>xxx.MYI: 存储索引</p>
<p><strong>Memory</strong></p>
<p>Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。</p>
<p><strong>特点</strong></p>
<p>内存存放</p>
<p>hash索引（默认）</p>
<p><strong>文件</strong></p>
<p>xxx.sdi：存储表结构信息</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h3><p>索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p>
<p><strong>无索引情况</strong></p>
<p>在无索引情况下，从第一行开始扫描，一直扫描到最后一行，我们称之为全表扫描，性能很低。</p>
<p><strong>有索引情况</strong></p>
<p>在进行查询时，只需要扫描B+tree(默认)的深度次就可以找到数据了，极大的提高的查询的效率。</p>
<p><strong>特点</strong></p>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>提高数据检索的效率，降低数据库的IO成本</td>
<td>索引列也是要占用空间的。</td>
</tr>
<tr>
<td>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。</td>
<td>索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低。</td>
</tr>
</tbody></table>
<h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种</p>
<table>
<thead>
<tr>
<th>索引结构</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>B+Tree索引</td>
<td>最常见的索引类型，大部分引擎都支持 B+树索引</td>
</tr>
<tr>
<td>Hash索引</td>
<td>底层数据结构是用哈希表实现的,只有精确匹配索引列的查询才有效,不支持范围查询</td>
</tr>
<tr>
<td>R-tree(空间索引）</td>
<td>空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td>
</tr>
<tr>
<td>Full-text(全文索引)</td>
<td>是一种通过建立倒排索引,快速匹配文档的方式。类似于 Lucene,Solr,ES</td>
</tr>
</tbody></table>
<p>不同的存储引擎对于索引结构的支持</p>
<table>
<thead>
<tr>
<th>索引</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>B+tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Hash 索引</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>R-tree 索引</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>Full-text</td>
<td>5.6版本之后支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<p><strong>注意</strong></p>
<p>如果没有特别指明，都是指B+树结构组织的索引。</p>
<p><strong>B+Tree</strong></p>
<p><strong>B-Tree特点</strong></p>
<p>5阶的B树，每一个节点最多存储4个key，对应5个指针。</p>
<p>一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。</p>
<p>在B树中，非叶子节点和叶子节点都会存放数据。</p>
<p><strong>B+Tree 与 B-Tree相比，主要有以下三点区别</strong></p>
<p>所有的数据都会出现在叶子节点。</p>
<p>叶子节点形成一个单向链表。</p>
<p>非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。</p>
<p><strong>MySQL中优化之后的 B+Tree</strong></p>
<p>在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。</p>
<p><img src="MySQL%E8%BF%9B%E9%98%B6.assets/image-20220327162837758-16483697209971.png" alt="image-20220327162837758"></p>
<p><strong>Hash</strong></p>
<p><strong>Hash结构</strong></p>
<p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在 hash表中。</p>
<p>如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</p>
<p><strong>Hash特点</strong></p>
<p>A. Hash索引只能用于对等比较(=，in)，不支持范围查询（between，&gt;，&lt; ，…）</p>
<p>B.无法利用索引完成排序操作</p>
<p>C.查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引</p>
<p><strong>存储引擎支持</strong></p>
<p>在MySQL中，支持hash索引的是Memory存储引擎。而InnoDB中具有自适应hash功能，hash索引是 InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的。</p>
<p><strong>InnoDB存储引擎选择使用B+tree索引结构的原因</strong></p>
<p>A.相对于二叉树，层级更少，搜索效率高；</p>
<p>B.对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；</p>
<p>C.相对Hash索引，B+tree支持范围匹配及排序操作；</p>
<h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><p>在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>主键索引</td>
<td>针对于表中主键创建的索引</td>
<td>默认自动创建,只能有一个</td>
<td>PRIMARY</td>
</tr>
<tr>
<td>唯一索引</td>
<td>避免同一个表中某数据列中的值重复</td>
<td>可以有多个</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>常规索引</td>
<td>快速定位特定数据</td>
<td>可以有多个</td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td>
<td>可以有多个</td>
<td>FULLTEXT</td>
</tr>
</tbody></table>
<p>而在在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种聚集索引和二级索引：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>聚集索引(Clustered Index)</td>
<td>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td>
<td>必须有,而且只有一个</td>
</tr>
<tr>
<td>二级索引(Secondary Index)</td>
<td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>
<td>可以存在多个</td>
</tr>
</tbody></table>
<p><strong>聚集索引选取规则</strong></p>
<p>如果存在主键，主键索引就是聚集索引。</p>
<p>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</p>
<p>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</p>
<p><img src="MySQL%E8%BF%9B%E9%98%B6.assets/image-20220327164317614-16483705990532.png" alt="image-20220327164317614"></p>
<p>聚集索引的叶子节点下挂的是这一行的数据。</p>
<p>二级索引的叶子节点下挂的是该字段值对应的主键值。</p>
<p><strong>回表查询</strong></p>
<p>这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，就称之为回表查询。</p>
<p>回表查询效率极低，通过建立合适的索引，避免回表查询。</p>
<h3 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> [ <span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT ] INDEX index_name <span class="keyword">ON</span> table_name (index_col_name,...);</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看索引</span></span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> table_name ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--删除索引</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name ;</span><br></pre></td></tr></table></figure>

<h3 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a>索引使用</h3><p><strong>最左前缀法则</strong></p>
<p>如果索引了多列（联合索引），要遵守最左前缀法则。</p>
<p>最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。</p>
<p>如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。</p>
<p>最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是第一个字段)必须<strong>存在</strong>，与我们编写SQL时，条件编写的先后<strong>顺序无关</strong>。</p>
<p><strong>范围查询</strong></p>
<p>联合索引中，出现范围查询(&gt;,&lt;)，范围查询右侧的列索引失效。</p>
<p><strong>索引失效情况</strong></p>
<p>索引列运算：在索引列上进行运算操作，索引将失效。</p>
<p>字符串不加引号：字符串类型字段使用时，不加引号，索引将失效。</p>
<p>模糊查询：如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p>
<p>or连接条件：用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</p>
<p>数据分布影响：如果MySQL评估使用索引比全表更慢，则不使用索引。</p>
<p><strong>SQL提示</strong></p>
<p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--建议使用</span></span><br><span class="line">use index </span><br><span class="line"></span><br><span class="line"><span class="comment">--忽略</span></span><br><span class="line">ignore index</span><br><span class="line"></span><br><span class="line"><span class="comment">--强制使用</span></span><br><span class="line">force index</span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名[ use <span class="operator">|</span> ignore <span class="operator">|</span> force ] index(索引名称) <span class="keyword">where</span> 条件;</span><br></pre></td></tr></table></figure>

<p><strong>覆盖索引</strong></p>
<p>尽量使用覆盖索引，减少select *。</p>
<p>覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到。</p>
<p><strong>前缀索引</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_xxxx <span class="keyword">on</span> table_name(<span class="keyword">column</span>(n));</span><br></pre></td></tr></table></figure>

<p>可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> 字段)<span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> 表名;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="built_in">substring</span>(字段,<span class="number">1</span>,<span class="number">5</span>))<span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure>

<p><strong>单列索引与联合索引</strong></p>
<p>单列索引：即一个索引只包含单个列。</p>
<p>联合索引：即一个索引包含了多个列。</p>
<p>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p>
<h3 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h3><p>1).针对于数据量较大，且查询比较频繁的表建立索引。</p>
<p>2).针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</p>
<p>3).尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</p>
<p>4).如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</p>
<p>5).尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</p>
<p>6).要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</p>
<p>7).如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含 NULL值时，它可以更好地确定哪个索引最有效地用于查询。</p>
<h3 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h3><p><strong>服务器状态信息</strong></p>
<p>MySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Com_______&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>通过上述指令，我们可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据库优化提供参考依据。</p>
<p>如果是以增删改为主，我们可以考虑不对其进行索引的优化。</p>
<p>如果是以查询为主，那么就要考虑对数据库的索引进行优化了。</p>
<p><strong>慢查询日志</strong></p>
<p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有 SQL语句的日志。</p>
<p>MySQL的慢查询日志默认没有开启，我们可以查看一下系统变量 slow_query_log。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;slow_query_log&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">开启MySQL慢日志查询开关</span></span><br><span class="line">slow_query_log=1</span><br><span class="line"><span class="meta">#</span><span class="bash">设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</span></span><br><span class="line">long_query_time=2</span><br></pre></td></tr></table></figure>

<p>配置完成后重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息(/var/lib/mysql/主机名-slow.log)</p>
<p><strong>profile</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查看当前MySQL是否支持profile操作</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@have</span>_profiling ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--开启profiling</span></span><br><span class="line"><span class="keyword">SET</span> profiling <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看每一条SQL的耗时基本情况</span></span><br><span class="line"><span class="keyword">show</span> profiles;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看指定query_id的SQL语句各个阶段的耗时情况</span></span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query query_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看指定query_id的SQL语句CPU的使用情况</span></span><br><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> query query_id;</span><br></pre></td></tr></table></figure>

<p><strong>explain</strong></p>
<p>EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--直接在select语句之前加上关键字 explain / desc</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件;</span><br></pre></td></tr></table></figure>

<p><strong>Explain 执行计划中各个字段的含义</strong></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>select查询的序列号，表示查询中执行select子句或者是操作表的顺序<br />id相同，执行顺序从上到下；id不同，值越大，越先执行。</td>
</tr>
<tr>
<td>select_type</td>
<td>表示 SELECT 的类型，常见的取值有<br />SIMPLE（简单表，即不使用表连接或者子查询）、<br />PRIMARY（主查询，即外层的查询）、<br />UNION（UNION 中的第二个或者后面的查询语句）、<br />SUBQUERY（SELECT/WHERE之后包含了子查询）等</td>
</tr>
<tr>
<td>type</td>
<td>表示连接类型，性能由好到差的连接类型为NULL、system、const、 eq_ref、ref、range、 index、all 。</td>
</tr>
<tr>
<td>possible_key</td>
<td>显示可能应用在这张表上的索引，一个或多个。</td>
</tr>
<tr>
<td>key</td>
<td>实际使用的索引，如果为NULL，则没有使用索引。</td>
</tr>
<tr>
<td>key_len</td>
<td>表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好。</td>
</tr>
<tr>
<td>rows</td>
<td>MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。</td>
</tr>
<tr>
<td>filtered</td>
<td>表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。</td>
</tr>
<tr>
<td>Extra</td>
<td>Using where; Using Index 查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数<br />Using index condition 查找使用了索引，但是需要回表查询数据</td>
</tr>
</tbody></table>
<h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><p><strong>插入数据</strong></p>
<p>一次性往数据库表中插入多条记录，可以从以下三个方面进行优化</p>
<p>1、批量插入数据</p>
<p>2、手动控制事务</p>
<p>3、主键顺序插入，性能要高于乱序插入</p>
<p>大批量插入数据以文件形式导入大数据</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">启动方式</span></span><br><span class="line">mysql --local-infile=1 -u root -p</span><br><span class="line"><span class="meta">#</span><span class="bash">全局设置</span></span><br><span class="line">set global local_infile = 1;</span><br><span class="line"><span class="meta">#</span><span class="bash">导入语法</span></span><br><span class="line">load data local infile &#x27;路径&#x27; into table 表名 fields terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>主键优化</strong></p>
<p>1).<strong>数据组织方式</strong></p>
<p>在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表(index organized table IOT)。</p>
<p>行数据，都是存储在聚集索引的叶子节点上的。</p>
<p>在InnoDB引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。</p>
<p>那也就意味着，一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不了，将会存储到下一个页中，页与页之间会通过指针连接。</p>
<p>2).<strong>页分裂</strong></p>
<p>页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行溢出)，根据主键排列。</p>
<p>主键乱序插入导致”页分裂”，是比较耗费性能的操作。</p>
<p>3).<strong>页合并</strong></p>
<p>删除为逻辑删除，，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。</p>
<p>当页中删除的记录达到 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。</p>
<p>发生的合并页的这个现象，就称之为”页合并”。</p>
<p>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或者创建索引时指定。</p>
<p><strong>4).索引设计原则</strong></p>
<p>满足业务需求的情况下，尽量降低主键的长度。</p>
<p>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</p>
<p>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</p>
<p>业务操作时，避免对主键的修改。</p>
<p><strong>order by优化</strong></p>
<p>MySQL的排序，有两种方式：</p>
<p>Using filesort : 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</p>
<p>Using index : 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。</p>
<p>Using index的性能高，而Using filesort的性能低，在优化排序操作时，尽量要优化为 Using index。</p>
<p>在MySQL中我们创建的索引，默认索引的叶子节点是从小到大排序的</p>
<p>在扫描时，反向扫描，就会出现 Backward index scan。</p>
<p>MySQL8版本中，支持降序索引，也可以创建降序索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--创建联合索引</span></span><br><span class="line"><span class="keyword">create</span> index 索引名称 <span class="keyword">on</span> 表名(字段<span class="number">1</span> <span class="keyword">asc</span> <span class="operator">|</span> <span class="keyword">desc</span> ,字段<span class="number">2</span> <span class="keyword">asc</span> <span class="operator">|</span> <span class="keyword">desc</span>);</span><br></pre></td></tr></table></figure>

<p><strong>order by优化原则</strong></p>
<p>A.根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</p>
<p>B.尽量使用覆盖索引。</p>
<p>C.多字段排序,一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。</p>
<p>D.如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size(默认256k)。</p>
<p><strong>group by优化</strong></p>
<p>对于分组操作，在联合索引中，也是符合最左前缀法则的。</p>
<p>以下两点进行优化，以提升性能：</p>
<p>A.在分组操作时，可以通过索引来提高效率。</p>
<p>B.分组操作时，索引的使用也是满足最左前缀法则的。</p>
<p><strong>limit优化</strong></p>
<p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。</p>
<p>优化思路: </p>
<p>一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。</p>
<p><strong>count优化</strong></p>
<p>MyISAM引擎把一个表的总行数存在了磁盘上，因此执行 count(*)的时候会直接返回这个数，效率很高；但是如果是带条件的count，MyISAM也慢。</p>
<p>InnoDB 引擎就麻烦了，它执行 count(*)的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</p>
<p>主要的优化思路：<strong>自己计数</strong></p>
<p><strong>count用法</strong></p>
<p>count()是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加1，否则不加，最后返回累计值。</p>
<table>
<thead>
<tr>
<th>count用法</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>count(主键)</td>
<td>InnoDB 引擎会遍历整张表，把每一行的主键id值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加(主键不可能为null)</td>
</tr>
<tr>
<td>count(字段)</td>
<td>没有not null 约束: InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加。<br />有not null 约束：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。</td>
</tr>
<tr>
<td>count(数字)</td>
<td>InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1”进去，直接按行进行累加。</td>
</tr>
<tr>
<td>count(*)</td>
<td>InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。</td>
</tr>
</tbody></table>
<p>按照效率排序的话，count(字段)&lt; count(主键 id)&lt; count(1)≈ count(*)，所以尽量使用 count(*)。</p>
<p><strong>update优化</strong></p>
<p>update语句执行时的注意事项</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--会锁定id为1这一行的数据，然后事务提交之后，行锁释放。</span></span><br><span class="line">update course <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;javaEE&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--当开启多个事务，在执行下面的SQL时，行锁升级为了表锁，导致该update语句的性能大大降低。</span></span><br><span class="line">update course <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;SpringBoot&#x27;</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;PHP&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁,并且该索引不能失效，否则会从行锁升级为表锁。</strong></p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图（View）是一种虚拟存在的表。</p>
<p>视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。</p>
<p>通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。</p>
<p>所以在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p>
<p>视图无法使用用户自定义变量。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--创建</span></span><br><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] <span class="keyword">VIEW</span> 视图名称[(列名列表)] <span class="keyword">AS</span> <span class="keyword">SELECT</span>语句[ <span class="keyword">WITH</span> [ <span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span> ] <span class="keyword">CHECK</span> OPTION ];</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看创建视图语句</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看视图数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 视图名称......;</span><br><span class="line"></span><br><span class="line"><span class="comment">--修改方式一</span></span><br><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] <span class="keyword">VIEW</span> 视图名称[(列名列表)] <span class="keyword">AS</span> <span class="keyword">SELECT</span>语句[ <span class="keyword">WITH</span> [ <span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span> ] <span class="keyword">CHECK</span> OPTION ];</span><br><span class="line"></span><br><span class="line"><span class="comment">--修改方式二</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> 视图名称[(列名列表)] <span class="keyword">AS</span> <span class="keyword">SELECT</span>语句[ <span class="keyword">WITH</span> [ <span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span> ] <span class="keyword">CHECK</span> OPTION ];</span><br><span class="line"></span><br><span class="line"><span class="comment">--删除</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> [IF <span class="keyword">EXISTS</span>]视图名称[,视图名称]...</span><br></pre></td></tr></table></figure>

<p><strong>检查选项</strong></p>
<p>当使用WITH CHECK OPTION子句创建视图时，MySQL会通过视图检查正在更改的每个行。</p>
<p>MySQL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。</p>
<p>为了确定检查的范围，mysql提供了两个选项： CASCADED 和 LOCAL ，默认值为 CASCADED 。</p>
<p>1).<strong>CASCADED 级联</strong></p>
<p>v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 cascaded，但是v1视图创建时未指定检查选项。则在执行检查时，不仅会检查v2，还会级联检查v2的关联视图v1。</p>
<p>2).<strong>LOCAL 本地</strong></p>
<p>v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 local ，但是v1视图创建时未指定检查选项。则在执行检查时，只会检查v2，不会检查v2的关联视图v1。</p>
<p><strong>视图的更新</strong></p>
<p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。</p>
<p>如果视图包含以下任何一项，则该视图不可更新：</p>
<p>A.聚合函数或窗口函数（SUM()、 MIN()、 MAX()、 COUNT()等）</p>
<p>B. DISTINCT </p>
<p>C. GROUP BY </p>
<p>D. HAVING </p>
<p>E. UNION 或者 UNION ALL</p>
<p><strong>视图作用</strong></p>
<p>1).简单</p>
<p>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。</p>
<p>2).安全</p>
<p>数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据。</p>
<p>3).数据独立</p>
<p>视图可帮助用户屏蔽真实表结构变化带来的影响。</p>
<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。</p>
<p>存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。</p>
<p><strong>特点</strong></p>
<p><strong>封装，复用</strong>: 可以把某一业务SQL封装在存储过程中，需要用到的时候直接调用即可。</p>
<p><strong>接收参数，返回数据</strong>: 再存储过程中，可以传递参数，也可以接收返回值。</p>
<p><strong>减少网络交互，效率提升</strong>: 如果涉及到多条SQL，每执行一次都是一次网络传输。封装在存储过程中，只需要网络交互一次即可。</p>
<p><strong>基本语法</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--创建</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名称([<span class="keyword">IN</span> <span class="operator">|</span> <span class="keyword">OUT</span> <span class="operator">|</span> <span class="keyword">INOUT</span> 参数列表])</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="comment">-- SQL语句</span></span><br><span class="line"><span class="keyword">END</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--调用</span></span><br><span class="line"><span class="keyword">CALL</span> 名称([ 参数]);</span><br><span class="line"></span><br><span class="line"><span class="comment">--查询指定数据库的存储过程及状态信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.ROUTINES <span class="keyword">WHERE</span> ROUTINE_SCHEMA <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">--查询某个存储过程的定义</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名称;</span><br><span class="line"></span><br><span class="line"><span class="comment">--删除</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> [ IF <span class="keyword">EXISTS</span> ]存储过程名称；</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<p>在命令行中，执行创建存储过程的SQL时，需要通过关键字 delimiter 指定SQL语句的结束符。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>在MySQL中变量分为三种类型: 系统变量、用户定义变量、局部变量。</p>
<p><strong>系统变量</strong></p>
<p>系统变量是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话变量（SESSION）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查看所有系统变量</span></span><br><span class="line"><span class="keyword">SHOW</span> [ SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span> ] VARIABLES ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--可以通过LIKE模糊匹配方式查找变量</span></span><br><span class="line"><span class="keyword">SHOW</span> [ SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span> ] VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;......&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看指定变量的值</span></span><br><span class="line"><span class="keyword">SELECT</span> @@[SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span>]系统变量名;</span><br><span class="line"></span><br><span class="line"><span class="comment">--设置系统变量</span></span><br><span class="line"><span class="keyword">SET</span> [ SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span> ]系统变量名<span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">SET</span> @@[ SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span> ]系统变量名<span class="operator">=</span> 值;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<p>如果没有指定SESSION/GLOBAL，默认是SESSION，会话变量。</p>
<p>A.全局变量(GLOBAL): 全局变量针对于所有的会话。</p>
<p>B.会话变量(SESSION): 会话变量针对于单个会话，在另外一个会话窗口就不生效了。</p>
<p><strong>用户定义变量</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--赋值</span></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@var</span>_name <span class="operator">=</span> expr [,<span class="variable">@var</span>_name <span class="operator">=</span> expr]...;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@var</span>_name :<span class="operator">=</span> expr [,<span class="variable">@var</span>_name :<span class="operator">=</span> expr]...;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@var</span>_name :<span class="operator">=</span> expr [,<span class="variable">@var</span>_name :<span class="operator">=</span> expr]...;</span><br><span class="line"><span class="keyword">SELECT</span> 字段名 <span class="keyword">INTO</span> <span class="variable">@var</span>_name <span class="keyword">FROM</span> 表名;</span><br><span class="line"></span><br><span class="line"><span class="comment">--使用</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@var</span>_name ;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<p>用户定义的变量无需对其进行声明或初始化，只不过获取到的值为NULL。</p>
<p><strong>局部变量</strong></p>
<p>局部变量是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。</p>
<p>可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN … END块。</p>
<p>变量类型就是数据库字段类型：INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--声明</span></span><br><span class="line"><span class="keyword">DECLARE</span> 变量名变量类型[<span class="keyword">DEFAULT</span> ...];</span><br><span class="line"></span><br><span class="line"><span class="comment">--赋值</span></span><br><span class="line"><span class="keyword">SET</span> 变量名<span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">SET</span> 变量名:<span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">SELECT</span> 字段名 <span class="keyword">INTO</span> 变量名 <span class="keyword">FROM</span> 表名...;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>IN</td>
<td>该类参数作为输入，也就是需要调用时传入值</td>
<td>默认</td>
</tr>
<tr>
<td>OUT</td>
<td>该类参数作为输出，也就是该参数可以作为返回值</td>
<td></td>
</tr>
<tr>
<td>INOUT</td>
<td>既可以作为输入参数，也可以作为输出参数</td>
<td></td>
</tr>
</tbody></table>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p><strong>if</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IF 条件<span class="number">1</span> <span class="keyword">THEN</span></span><br><span class="line">.....</span><br><span class="line">ELSEIF 条件<span class="number">2</span> <span class="keyword">THEN</span> <span class="comment">--可选</span></span><br><span class="line">.....</span><br><span class="line"><span class="keyword">ELSE</span> <span class="comment">--可选</span></span><br><span class="line">.....</span><br><span class="line"><span class="keyword">END</span> IF;</span><br></pre></td></tr></table></figure>

<p><strong>case</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CASE</span> case_value</span><br><span class="line"></span><br><span class="line"><span class="keyword">WHEN</span> when_value1 <span class="keyword">THEN</span> statement_list1</span><br><span class="line"></span><br><span class="line">[ <span class="keyword">WHEN</span> when_value2 <span class="keyword">THEN</span> statement_list2]...</span><br><span class="line"></span><br><span class="line">[ <span class="keyword">ELSE</span> statement_list ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CASE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WHEN</span> search_condition1 <span class="keyword">THEN</span> statement_list1</span><br><span class="line"></span><br><span class="line">[<span class="keyword">WHEN</span> search_condition2 <span class="keyword">THEN</span> statement_list2]...</span><br><span class="line"></span><br><span class="line">[<span class="keyword">ELSE</span> statement_list]</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br></pre></td></tr></table></figure>

<p><strong>while</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--先判定条件，如果条件为true，则执行逻辑，否则，不执行逻辑</span></span><br><span class="line">WHILE 条件 DO</span><br><span class="line"></span><br><span class="line">	<span class="keyword">SQL</span>逻辑...</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span> WHILE;</span><br></pre></td></tr></table></figure>

<p><strong>repeat</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--先执行一次逻辑，然后判定UNTIL条件是否满足，如果满足，则退出。如果不满足，则继续下一次循环</span></span><br><span class="line">REPEAT</span><br><span class="line"></span><br><span class="line">	<span class="keyword">SQL</span>逻辑...</span><br><span class="line"></span><br><span class="line">UNTIL 条件</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span> REPEAT;</span><br></pre></td></tr></table></figure>

<p><strong>loop</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[begin_label:] LOOP</span><br><span class="line"></span><br><span class="line">	<span class="keyword">SQL</span>逻辑...</span><br><span class="line">	</span><br><span class="line"><span class="keyword">END</span> LOOP [end_label];</span><br><span class="line"></span><br><span class="line">LEAVE label; <span class="comment">--退出指定标记的循环体</span></span><br><span class="line">ITERATE label; <span class="comment">--直接进入下一次循环</span></span><br></pre></td></tr></table></figure>

<h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><p>游标（CURSOR）是用来存储查询结果集的数据类型,在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--声明游标</span></span><br><span class="line"><span class="keyword">DECLARE</span> 游标名称 <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> 查询语句;</span><br><span class="line"></span><br><span class="line"><span class="comment">--打开游标</span></span><br><span class="line"><span class="keyword">OPEN</span> 游标名称;</span><br><span class="line"></span><br><span class="line"><span class="comment">--获取游标记录</span></span><br><span class="line"><span class="keyword">FETCH</span> 游标名称 <span class="keyword">INTO</span> 变量[,变量];</span><br><span class="line"></span><br><span class="line"><span class="comment">--关闭游标</span></span><br><span class="line"><span class="keyword">CLOSE</span> 游标名称;</span><br></pre></td></tr></table></figure>

<h3 id="条件处理程序"><a href="#条件处理程序" class="headerlink" title="条件处理程序"></a>条件处理程序</h3><p>条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。具体语法为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> handler_action HANDLER</span><br><span class="line"> <span class="keyword">FOR</span> condition_value [, condition_value]...</span><br><span class="line"> statement</span><br><span class="line"></span><br><span class="line">handler_action: &#123;</span><br><span class="line"> CONTINUE</span><br><span class="line"><span class="operator">|</span> EXIT</span><br><span class="line"><span class="operator">|</span> UNDO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">condition_value: &#123;</span><br><span class="line"> mysql_error_code</span><br><span class="line"><span class="operator">|</span> <span class="keyword">SQLSTATE</span> [<span class="keyword">VALUE</span>] sqlstate_value</span><br><span class="line"><span class="operator">|</span> condition_name</span><br><span class="line"><span class="operator">|</span> <span class="keyword">SQLWARNING</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NOT</span> FOUND</span><br><span class="line"><span class="operator">|</span> <span class="keyword">SQLEXCEPTION</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handler_action <span class="comment">--满足处理程序条件时，采取的策略</span></span><br><span class="line"></span><br><span class="line">CONTINUE: <span class="comment">--继续执行当前程序</span></span><br><span class="line"></span><br><span class="line">EXIT: <span class="comment">--终止执行当前程序</span></span><br><span class="line"></span><br><span class="line">condition_value <span class="comment">--的取值：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SQLSTATE</span> sqlstate_value: <span class="comment">--状态码，如02000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SQLWARNING</span>: <span class="comment">--所有以01开头的SQLSTATE代码的简写</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">NOT</span> FOUND: <span class="comment">--所有以02开头的SQLSTATE代码的简写</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SQLEXCEPTION</span>: <span class="comment">--所有没有被SQLWARNING 或 NOT FOUND捕获的SQLSTATE代码的简写</span></span><br></pre></td></tr></table></figure>

<h3 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h3><p>存储函数是有返回值的存储过程，存储函数的参数只能是IN类型的。具体语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> 存储函数名称([ 参数列表])</span><br><span class="line"></span><br><span class="line"><span class="keyword">RETURNS</span> type [characteristic ...]</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">-- SQL语句</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">RETURN</span> ...;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">END</span> ;</span><br></pre></td></tr></table></figure>

<p>characteristic说明：</p>
<p>DETERMINISTIC：相同的输入参数总是产生相同的结果</p>
<p>NO SQL ：不包含 SQL 语句。</p>
<p>READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句。</p>
<p>在mysql8.0版本中binlog默认是开启的，一旦开启了，mysql就要求在定义存储过程时，需要指定 characteristic特性，否则就会报错</p>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器是与表有关的数据库对象，指在insert/update/delete之前(BEFORE)或之后(AFTER)，触发并执行触发器中定义的SQL语句集合。</p>
<p>触发器的这种特性可以协助应用在数据库端确保数据的完整性,日志记录,数据校验等操作。</p>
<p>使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。</p>
<p>现在触发器还只支持行级触发，不支持语句级触发。</p>
<table>
<thead>
<tr>
<th>触发器类型</th>
<th>NEW 和 OLD</th>
</tr>
</thead>
<tbody><tr>
<td>INSERT 型触发器</td>
<td>NEW 表示将要或者已经新增的数据</td>
</tr>
<tr>
<td>UPDATE 型触发器</td>
<td>OLD 表示修改之前的数据, NEW 表示将要或已经修改后的数据</td>
</tr>
<tr>
<td>DELETE 型触发器</td>
<td>OLD 表示将要或者已经删除的数据</td>
</tr>
</tbody></table>
<p><strong>语法</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--创建</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name</span><br><span class="line"></span><br><span class="line">BEFORE<span class="operator">/</span>AFTER <span class="keyword">INSERT</span><span class="operator">/</span>UPDATE<span class="operator">/</span><span class="keyword">DELETE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ON</span> tbl_name <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="comment">--行级触发器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">	trigger_stmt ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看</span></span><br><span class="line"><span class="keyword">SHOW</span> TRIGGERS ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--删除</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> [schema_name.]trigger_name ; <span class="comment">--如果没有指定 schema_name，默认为当前数据库。</span></span><br></pre></td></tr></table></figure>

<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、 RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p>
<p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p>
<p>全局锁：锁定数据库中的所有表。</p>
<p>表级锁：每次操作锁住整张表。</p>
<p>行级锁：每次操作锁住对应的行数据。</p>
<h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。</p>
<p>其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--加全局锁</span></span><br><span class="line">flush tables <span class="keyword">with</span> read lock ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--数据备份</span></span><br><span class="line">mysqldump <span class="operator">-</span>uroot –p1234 数据库名<span class="operator">&gt;</span> xxxx.sql</span><br><span class="line"></span><br><span class="line"><span class="comment">--释放锁</span></span><br><span class="line">unlock tables ;</span><br></pre></td></tr></table></figure>

<p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p>
<p>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</p>
<p>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</p>
<p>在InnoDB引擎中，我们可以在备份时加上参数–single-transaction 参数来完成不加锁的一致性数据备份。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="comment">--single-transaction -uroot –p123456 数据库名&gt; xxxx.sql</span></span><br></pre></td></tr></table></figure>

<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、 InnoDB、BDB等存储引擎中。</p>
<p>对于表级锁，主要分为三类：表锁元数据锁（meta data lock，MDL）意向锁</p>
<p><strong>表锁</strong></p>
<p>对于表锁，分为两类：</p>
<p>表共享读锁（read lock）</p>
<p>表独占写锁（write lock）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--加锁</span></span><br><span class="line">lock tables 表名... read <span class="operator">|</span> write。</span><br><span class="line"></span><br><span class="line"><span class="comment">--释放锁</span></span><br><span class="line">unlock tables <span class="operator">|</span>客户端断开连接。</span><br></pre></td></tr></table></figure>

<p>读锁</p>
<p><img src="MySQL%E8%BF%9B%E9%98%B6.assets/image-20220328154033222-16484532353571.png" alt="image-20220328154033222"></p>
<p>写锁</p>
<p><img src="MySQL%E8%BF%9B%E9%98%B6.assets/image-20220328154144182-16484533059962.png" alt="image-20220328154144182"></p>
<p><strong>结论</strong></p>
<p>读锁不会阻塞其他客户端的读，但是会阻塞写。</p>
<p>写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。</p>
<p><strong>元数据锁</strong></p>
<p>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。</p>
<p>MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。</p>
<p>为了避免DML与 DDL冲突，保证读写的正确性。</p>
<p>某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的。</p>
<p>在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)。</p>
<table>
<thead>
<tr>
<th>对应SQL</th>
<th>锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lock tables xxx read / write</td>
<td>SHARED_READ_ONLY / SHARED_NO_READ_WRITE</td>
<td></td>
</tr>
<tr>
<td>select 、select … lock in share mode</td>
<td>SHARED_READ</td>
<td>与SHARED_READ、 SHARED_WRITE兼容，与 EXCLUSIVE互斥</td>
</tr>
<tr>
<td>insert 、update、 delete、select … for update</td>
<td>SHARED_WRITE</td>
<td>与SHARED_READ、 SHARED_WRITE兼容，与 EXCLUSIVE互斥</td>
</tr>
<tr>
<td>alter table …</td>
<td>EXCLUSIVE</td>
<td>与其他的MDL都互斥</td>
</tr>
</tbody></table>
<p><strong>总结</strong></p>
<p>有事务进行时，不能对表结构进行修改，但是可以增删改查表中数据；</p>
<p><strong>意向锁</strong></p>
<p>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</p>
<p>在执行DML操作时，会对涉及的行加行锁，同时也会对该表加上意向锁。</p>
<p>而其他客户端，在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而不用逐行判断行锁情况了。</p>
<p><strong>意向共享锁(IS)</strong>: </p>
<p>由语句select … lock in share mode添加。</p>
<p>与表锁共享锁(read)兼容，与表锁排他锁(write)互斥。</p>
<p><strong>意向排他锁(IX)</strong>: </p>
<p>由insert、update、delete、select…for update添加。</p>
<p>与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。</p>
<p>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看锁</span></span><br><span class="line"><span class="keyword">select</span> object_schema,object_name,index_name,lock_type,lock_mode,lock_data <span class="keyword">from</span> performance_schema.data_locks;</span><br></pre></td></tr></table></figure>

<h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在 InnoDB存储引擎中。</p>
<p>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。</p>
<p>对于行级锁，主要分为以下三类：</p>
<p>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。</p>
<p>间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。</p>
<p>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。</p>
<p><strong>行锁</strong></p>
<p>InnoDB实现了以下两种类型的行锁：</p>
<p>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</p>
<p>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</p>
<table>
<thead>
<tr>
<th align="center">当前锁类型\请求锁类型</th>
<th>S(共享锁)</th>
<th>X(排他锁)</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>S(共享锁)</strong></td>
<td>兼容</td>
<td>冲突</td>
</tr>
<tr>
<td align="center"><strong>X(排他锁)</strong></td>
<td>冲突</td>
<td>冲突</td>
</tr>
</tbody></table>
<p>常见的SQL语句，在执行时，所加的行锁如下：</p>
<table>
<thead>
<tr>
<th>SQL</th>
<th>行锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>INSERT …</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>UPDATE …</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>DELETE …</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>SELECT（正常）</td>
<td>不加任何锁</td>
<td></td>
</tr>
<tr>
<td>SELECT … LOCK IN SHARE MODE</td>
<td>共享锁</td>
<td>需要手动在SELECT之后加LOCK IN SHARE MODE</td>
</tr>
<tr>
<td>SELECT … FOR UPDATE</td>
<td>排他锁</td>
<td>需要手动在SELECT之后加FOR UPDATE</td>
</tr>
</tbody></table>
<p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p>
<p>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</p>
<p>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。</p>
<p><strong>间隙锁&amp;临键锁</strong></p>
<p>索引上的等值查询(唯一索引)，给不存在的记录加锁时,优化为间隙锁。</p>
<p>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。</p>
<p>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</p>
<p>间隙锁唯一目的是防止其他事务插入间隙。</p>
<p>间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</p>
<p>间隙锁防止幻读，阻塞别的客户端对记录前后进行插入，防止了幻读的产生。</p>
<h2 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h2><h3 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h3><p><img src="MySQL%E8%BF%9B%E9%98%B6.assets/image-20220329144311774-16485361947552.png" alt="image-20220329144311774"></p>
<p>1).<strong>表空间</strong></p>
<p>表空间是InnoDB存储引擎逻辑结构的最高层，如果用户启用了参数 innodb_file_per_table(在8.0版本中默认开启)，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。</p>
<p>2).<strong>段</strong></p>
<p>段，分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点，索引段即为B+树的非叶子节点。段用来管理多个Extent（区）。</p>
<p>3).<strong>区</strong></p>
<p>区，表空间的单元结构，每个区的大小为1M。默认情况下， InnoDB存储引擎页大小为16K，即一个区中一共有64个连续的页。</p>
<p>4).<strong>页</strong></p>
<p>页，是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为16KB。为了保证页的连续性， InnoDB 存储引擎每次从磁盘申请4-5 个区。</p>
<p>5).<strong>行</strong></p>
<p>行，InnoDB 存储引擎数据是按行进行存放的。</p>
<p>在行中，<strong>默认有两个隐藏字段</strong>：</p>
<p>Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。</p>
<p>Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</p>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>MySQL5.5 版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用非常广泛。</p>
<p>下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。</p>
<p><img src="MySQL%E8%BF%9B%E9%98%B6.assets/image-20220329144728649-16485364500183.png" alt="image-20220329144728649"></p>
<h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a><strong>内存结构</strong></h3><p>在左侧的内存结构中，主要分为这么四大块儿： Buffer Pool、Change Buffer、Adaptive Hash Index、Log Buffer。</p>
<p>1).<strong>Buffer Pool</strong></p>
<p>InnoDB存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能弥补这两者之间的I/O效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁盘I/O。</p>
<p>在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及 InnoDB的锁信息等等。</p>
<p>缓冲池 Buffer Pool，是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。</p>
<p>缓冲池以Page页为单位，底层采用链表数据结构管理Page。</p>
<p>根据状态，将Page分为三种类型：</p>
<p>• free page：空闲page，未被使用。</p>
<p>• clean page：被使用page，数据没有被修改过。</p>
<p>• dirty page：脏页，被使用page，数据被修改过，池中数据与磁盘的数据产生了不一致。</p>
<p>在专用服务器上，通常将多达80％的物理内存分配给缓冲池。</p>
<p>参数设置：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_buffer_pool_size&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>2).<strong>Change Buffer</strong></p>
<p>Change Buffer，更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据Page 没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer 中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。</p>
<p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了 ChangeBuffer之后，可以在缓冲池中进行合并处理，减少磁盘IO。</p>
<p>3).<strong>Adaptive Hash Index</strong></p>
<p>自适应hash索引，用于优化对Buffer Pool数据的查询。</p>
<p>MySQL的innoDB引擎中虽然没有直接支持 hash索引，但是给我们提供了一个功能就是这个自适应hash索引。hash索引在进行等值匹配时，一般性能是要高于B+树的，因为hash索引一般只需要一次IO即可，而B+树，可能需要几次匹配，所以hash索引的效率要高，但是hash索引又不适合做范围查询、模糊匹配等。</p>
<p>InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。</p>
<p>自适应哈希索引，无需人工干预，是系统根据情况自动完成。</p>
<p>参数： adaptive_hash_index</p>
<p>4).<strong>Log Buffer</strong></p>
<p>Log Buffer：日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log 、undo log），默认大小为16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I/O。</p>
<p>参数: </p>
<p>innodb_log_buffer_size：缓冲区大小</p>
<p>innodb_flush_log_at_trx_commit：日志刷新到磁盘时机，取值主要包含以下三个：</p>
<p>1: 日志在每次事务提交时写入并刷新到磁盘，默认值。</p>
<p>0: 每秒将日志写入并刷新到磁盘一次。</p>
<p>2: 日志在每次事务提交后写入，并每秒刷新到磁盘一次。</p>
<h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a><strong>磁盘结构</strong></h3><p>1).<strong>System Tablespace</strong></p>
<p>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等)</p>
<p>参数：innodb_data_file_path</p>
<p>系统表空间，默认的文件名叫 ibdata1。</p>
<p>2).<strong>File-Per-Table Tablespaces</strong></p>
<p>如果开启了innodb_file_per_table开关，则每个表的文件表空间包含单个InnoDB表的数据和索引，并存储在文件系统上的单个数据文件中。</p>
<p>开关参数：innodb_file_per_table ，该参数默认开启。</p>
<p>每创建一个表，都会产生一个表空间文件</p>
<p>3).<strong>General Tablespaces</strong></p>
<p>通用表空间，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空间。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--创建表空间</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>SPACE ts_name <span class="keyword">ADD</span> DATAFILE <span class="string">&#x27;file_name&#x27;</span> ENGINE <span class="operator">=</span> engine_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">--创建表时指定表空间</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> xxx ... TABLESPACE ts_name;</span><br></pre></td></tr></table></figure>

<p>4).<strong>Undo Tablespaces</strong></p>
<p>撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存储 undo log日志。</p>
<p>5).<strong>Temporary Tablespaces</strong></p>
<p>InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</p>
<p>6).<strong>Doublewrite Buffer Files</strong></p>
<p>双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。</p>
<p>7).<strong>Redo Log</strong></p>
<p>重做日志，是用来实现事务的持久性。</p>
<p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。</p>
<p>当事务提交之后会把所有修改信息都会存到该日志中,用于在刷新脏页到磁盘时,发生错误时,进行数据恢复使用。</p>
<p>以循环方式写入重做日志文件，涉及两个文件：ib_logfile0、ib_logfile1</p>
<h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><p>内存中所更新的数据，到磁盘中，就涉及到一组后台线程，一些InnoDB中涉及到的后台线程。</p>
<p>在InnoDB的后台线程中，分为4类，分别是：Master Thread 、IO Thread、Purge Thread、 Page Cleaner Thread。</p>
<p>1).<strong>Master Thread</strong></p>
<p>核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中,保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收。</p>
<p>2).<strong>IO Thread</strong></p>
<p>在InnoDB存储引擎中大量使用了AIO来处理IO请求,这样可以极大地提高数据库的性能，而IO Thread主要负责这些IO请求的回调。</p>
<table>
<thead>
<tr>
<th>线程类型</th>
<th>默认个数</th>
<th>职责</th>
</tr>
</thead>
<tbody><tr>
<td>Read thread</td>
<td>4</td>
<td>负责读操作</td>
</tr>
<tr>
<td>Write thread</td>
<td>4</td>
<td>负责写操作</td>
</tr>
<tr>
<td>Log thread</td>
<td>1</td>
<td>负责将日志缓冲区刷新到磁盘</td>
</tr>
<tr>
<td>Insert buffer thread</td>
<td>1</td>
<td>负责将写缓冲区内容刷新到磁盘</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查看到InnoDB的状态信息，其中就包含IO Thread信息。</span></span><br><span class="line"><span class="keyword">show</span> engine innodb status \G;</span><br></pre></td></tr></table></figure>

<p>3).<strong>Purge Thread</strong></p>
<p>主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就用它来回收。</p>
<p>4).<strong>Page Cleaner Thread</strong></p>
<p>协助 Master Thread 刷新脏页到磁盘的线程，它可以减轻 Master Thread 的工作压力，减少阻塞。</p>
<h3 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h3><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p>
<p>•原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</p>
<p>•一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</p>
<p>•隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</p>
<p>•持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</p>
<p>研究事务的原理，就是研究MySQL的InnoDB引擎是如何保证事务的这四大特性的。</p>
<p>对于这四大特性，实际上分为两个部分。其中的原子性、一致性、持久化，实际上是由InnoDB中的两份日志来保证的，一份是redo log日志，一份是undo log日志。而隔离性是通过数据库的锁，加上MVCC来保证的。</p>
<p><img src="MySQL%E8%BF%9B%E9%98%B6.assets/image-20220329151616445-16485381781014.png" alt="image-20220329151616445"></p>
<p><strong>redo log</strong></p>
<p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。</p>
<p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file）,前者是在内存中，后者在磁盘中。</p>
<p>当事务提交之后会把所有修改信息都存到该日志文件中,用于在刷新脏页到磁盘,发生错误时,进行数据恢复使用。</p>
<p>缓冲区的脏页数据并不是实时刷新的，而是一段时间之后 将缓冲区的数据刷新到磁盘中，假如刷新到磁盘的过程出错了，而提示给用户事务提交成功，而数据却没有持久化下来，这就出现问题了，没有保证事务的持久性。</p>
<p><img src="MySQL%E8%BF%9B%E9%98%B6.assets/image-20220329152031679-16485384330165.png" alt="image-20220329152031679"></p>
<p>有了redolog之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在redo log buffer中。</p>
<p>在事务提交时，会将redo log buffer中的数据刷新到redo log磁盘文件中。过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据恢复，这样就保证了事务的持久性。</p>
<p>而如果脏页成功刷新到磁盘或者涉及到的数据已经落盘，此时redolog就没有作用了，就可以删除了，所以存在的两个redolog文件是循环写的。</p>
<p>每一次提交事务，要刷新redo log 到磁盘中呢，而不是直接将buffer pool中的脏页刷新到磁盘</p>
<p>在业务操作中，操作数据一般都是随机读写磁盘的，而不是顺序读写磁盘。 </p>
<p>而redo log在 往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。</p>
<p>顺序写的效率，要远大于随机写。 这种先写日志的方式，称之为 WAL（Write-Ahead Logging）。</p>
<p><strong>undo log</strong></p>
<p>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性) 和 MVCC(多版本并发控制) 。</p>
<p>undo log和redo log记录物理日志不一样，它是逻辑日志。</p>
<p>可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的 update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</p>
<p>Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些 日志可能还用于MVCC。 </p>
<p>Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的 rollback segment 回滚段中，内部包含1024个undo log segment。</p>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>1). <strong>当前读</strong></p>
<p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</p>
<p>对于日常的操作，如：select … lock in share mode(共享锁)，select … for update、update、insert、delete(排他锁)都是一种当前读。</p>
<p>2). <strong>快照读</strong></p>
<p>简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据， 不加锁，是非阻塞读。 </p>
<p>• Read Committed：每次select，都生成一个快照读。 </p>
<p>• Repeatable Read：开启事务后第一个select语句才是快照读的地方。 </p>
<p>• Serializable：快照读会退化为当前读。</p>
<p>3). <strong>MVCC</strong> </p>
<p>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本， 使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。</p>
<p>MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。 </p>
<p><strong>隐藏字段</strong> </p>
<table>
<thead>
<tr>
<th>隐藏字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>DB_TRX_ID</td>
<td>最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。</td>
</tr>
<tr>
<td>DB_ROLL_PTR</td>
<td>回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本。</td>
</tr>
<tr>
<td>DB_ROW_ID</td>
<td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入mysql文件夹</span></span><br><span class="line">cd /var/lib/mysql/数据库名/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看表结构信息</span></span><br><span class="line">ibd2sdi 表名.ibd</span><br></pre></td></tr></table></figure>

<p><strong>undolog</strong> </p>
<p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。 </p>
<p>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。 </p>
<p>而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。</p>
<p>版本链</p>
<p>DB_TRX_ID : 代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是自增的。 </p>
<p>DB_ROLL_PTR ： 由于这条数据是才插入的，没有被更新过，所以该字段值为null。</p>
<p>不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表</p>
<p>链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p>
<p><strong>readview</strong></p>
<p>ReadView（读视图）是快照读SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务 （未提交的）id。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>m_ids</td>
<td>当前活跃的事务ID集合</td>
</tr>
<tr>
<td>min_trx_id</td>
<td>最小活跃事务ID</td>
</tr>
<tr>
<td>max_trx_id</td>
<td>预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）</td>
</tr>
<tr>
<td>creator_trx_id</td>
<td>ReadView创建者的事务ID</td>
</tr>
</tbody></table>
<p>在readview中就规定了版本链数据的访问规则： trx_id 代表当前undolog版本链对应事务ID。</p>
<table>
<thead>
<tr>
<th>条件</th>
<th>是否可以访问</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>trx_id == creator_trx_id</td>
<td>可以访问该版本</td>
<td>成立，说明数据是当前这个事务更改的。</td>
</tr>
<tr>
<td>trx_id &lt; min_trx_id</td>
<td>可以访问该版本</td>
<td>成立，说明数据已经提交了。</td>
</tr>
<tr>
<td>trx_id &gt; max_trx_id</td>
<td>不可以访问该版本</td>
<td>成立，说明该事务是在 ReadView生成后才开启。</td>
</tr>
<tr>
<td>min_trx_id &lt;= trx_id &lt;= max_trx_id</td>
<td>trx_id不在m_ids中，是可以访问该版的</td>
<td>成立，说明数据已经提交。</td>
</tr>
</tbody></table>
<p>不同的隔离级别，生成ReadView的时机不同： </p>
<p>READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。 </p>
<p>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</p>
<p><img src="MySQL%E8%BF%9B%E9%98%B6.assets/image-20220329154501371-16485399028726.png" alt="image-20220329154501371"></p>
<p>MVCC的实现原理就是通过 InnoDB表的隐藏字段、UndoLog 版本链、ReadView来实现的。 而MVCC + 锁，则实现了事务的隔离性。 而一致性则是由redolog 与 undolog保证。</p>
<h2 id="MySQL管理"><a href="#MySQL管理" class="headerlink" title="MySQL管理"></a>MySQL管理</h2><h3 id="系统数据库"><a href="#系统数据库" class="headerlink" title="系统数据库"></a>系统数据库</h3><p>Mysql数据库安装完成后，自带了一下四个数据库，具体作用如下：</p>
<table>
<thead>
<tr>
<th>数据库</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>mysql</td>
<td>存储MySQL服务器正常运行所需要的各种信息 （时区、主从、用 户、权限等）</td>
</tr>
<tr>
<td>information_schema</td>
<td>提供了访问数据库元数据的各种表和视图，包含数据库、表、字段类型及访问权限等</td>
</tr>
<tr>
<td>performance_schema</td>
<td>为MySQL服务器运行时状态提供了一个底层监控功能，主要用于收集数据库服务器性能参数</td>
</tr>
<tr>
<td>sys</td>
<td>包含了一系列方便 DBA 和开发人员利用 performance_schema 性能数据库进行性能调优和诊断的视图</td>
</tr>
</tbody></table>
<h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><p><strong>mysql</strong></p>
<p>该mysql不是指mysql服务，而是指mysql的客户端工具。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 语法 ：</span></span><br><span class="line">mysql [options] [database]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 选项 ：</span></span><br><span class="line">-u, --user=name 								#指定用户名</span><br><span class="line">-p, --password[=name] 							#指定密码</span><br><span class="line">-h, --host=name 								#指定服务器IP或域名</span><br><span class="line">-P, --port=port 								#指定连接端口</span><br><span class="line">-e, --execute=name 								#执行SQL语句并退出</span><br></pre></td></tr></table></figure>

<p>-e选项可以在Mysql客户端执行SQL语句，而不用连接到MySQL数据库再执行，对于一些批处理脚本， 这种方式尤其方便。</p>
<p><strong>mysqladmin</strong></p>
<p>mysqladmin 是一个执行管理操作的客户端程序。可以用它来检查服务器的配置和当前状态、创建并删除数据库等。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过帮助文档查看选项：</span></span><br><span class="line">mysqladmin --help</span><br><span class="line"></span><br><span class="line">mysqladmin [options] command ...</span><br><span class="line"></span><br><span class="line">-u, --user=name 								#指定用户名</span><br><span class="line">-p, --password[=name] 							#指定密码</span><br><span class="line">-h, --host=name 								#指定服务器IP或域名</span><br><span class="line">-P, --port=port 								#指定连接端口</span><br></pre></td></tr></table></figure>

<p><strong>mysqlbinlog</strong></p>
<p>由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文本的文本格式，就会使 用到mysqlbinlog 日志管理工具。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog [options] log-files1 log-files2 ...</span><br><span class="line"></span><br><span class="line">-d, --database=name 							#指定数据库名称，只列出指定的数据库相关操作。</span><br><span class="line">-o, --offset=									#忽略掉日志中的前n行命令。</span><br><span class="line">-r,--result-file=name 							#将输出的文本格式日志输出到指定文件。</span><br><span class="line">-s, --short-form 								#显示简单格式，省略掉一些信息。</span><br><span class="line">--start-datatime=date1 --stop-datetime=date2 	#指定日期间隔内的所有日志。</span><br><span class="line">--start-position=pos1 --stop-position=pos2 		#指定位置间隔内的所有日志。</span><br></pre></td></tr></table></figure>

<p><strong>mysqlshow</strong></p>
<p>mysqlshow 客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或者索引。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysqlshow [options] [db_name [table_name [col_name]]]</span><br><span class="line"></span><br><span class="line">--count 										#显示数据库及表的统计信息（数据库，表 均可以不指定）</span><br><span class="line">-i 												#显示指定数据库或者指定表的状态信息</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">示例：</span></span><br><span class="line">mysqlshow -uroot -p2143 test --count			#查询test库中每个表中的字段书，及行数</span><br><span class="line">mysqlshow -uroot -p2143 test book --count		#查询test库中book表的详细情况</span><br></pre></td></tr></table></figure>

<p><strong>mysqldump</strong></p>
<p>mysqldump 客户端工具用来备份数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，及插入表的SQL语句。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysqldump [options] db_name [tables]</span><br><span class="line">mysqldump [options] --database/-B db1 [db2 db3...]</span><br><span class="line">mysqldump [options] --all-databases/-A</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">连接选项 ：</span></span><br><span class="line">-u, --user=name 			#指定用户名</span><br><span class="line">-p, --password[=name] 		#指定密码</span><br><span class="line">-h, --host=name 			#指定服务器ip或域名</span><br><span class="line">-P, --port=					#指定连接端口</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">输出选项：</span></span><br><span class="line">--add-drop-database 		#在每个数据库创建语句前加上 drop database 语句</span><br><span class="line">--add-drop-table 			#在每个表创建语句前加上 drop table 语句 , 默认开启; </span><br><span class="line">--skip-add-drop-table		#不开启</span><br><span class="line">-n, --no-create-db 			#不包含数据库的创建语句</span><br><span class="line">-t, --no-create-info 		#不包含数据表的创建语句</span><br><span class="line">-d --no-data 				#不包含数据</span><br><span class="line">-T, --tab=name 				#自动生成两个文件：一个.sql文件，创建表结构的语句；一个.txt文件，数据文件</span><br></pre></td></tr></table></figure>

<p><strong>mysqlimport/source</strong></p>
<p>mysqlimport 是客户端数据导入工具，用来导入mysqldump 加 -T 参数后导出的文本文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 语法 ：</span></span><br><span class="line">mysqlimport [options] db_name textfile1 [textfile2...]</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例 ：</span></span><br><span class="line">mysqlimport -uroot -p2143 test /tmp/city.txt</span><br></pre></td></tr></table></figure>

<p>如果需要导入sql文件,可以使用mysql中的source 指令 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 语法 ：</span></span><br><span class="line">source /root/xxxxx.sql</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/database/" rel="tag"># database</a>
          </div>

        
  <div class="post-widgets">
    <div class="wpac-rating-container">
      <div id="wpac-rating"></div>
    </div>
  </div>

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/03/16/MySQL/" rel="prev" title="MySQL">
                  <i class="fa fa-chevron-left"></i> MySQL
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/03/31/JavaWeb/" rel="next" title="JavaWeb">
                  JavaWeb <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">未名</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
  <script src="https://embed.widgetpack.com/widget.js" async></script>
  <script class="next-config" data-name="rating" type="application/json">{"enable":true,"id":null,"color":"#fc6423"}</script>
  <script src="/js/third-party/rating.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
