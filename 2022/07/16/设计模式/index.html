<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>设计模式 | 未名的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="目标松耦合设计思想  面向对象设计原则 重构技法改善设计  GOF 核心设计模式 什么是设计模式  ​    “每一个模式描述了一个在我们周围不断重复发生的问题， 以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动”。 ——Christopher Alexander 设计模式概括从面向对象谈起底层思维：向下，如何把握机器底层 从微观理解对象构造  • 语言构造  • 编">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式">
<meta property="og:url" content="https://shallowshades.github.io.git/2022/07/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="未名的博客">
<meta property="og:description" content="目标松耦合设计思想  面向对象设计原则 重构技法改善设计  GOF 核心设计模式 什么是设计模式  ​    “每一个模式描述了一个在我们周围不断重复发生的问题， 以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动”。 ——Christopher Alexander 设计模式概括从面向对象谈起底层思维：向下，如何把握机器底层 从微观理解对象构造  • 语言构造  • 编">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://shallowshades.github.io.git/2022/07/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220717215938881.png">
<meta property="og:image" content="https://shallowshades.github.io.git/2022/07/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220717220730182.png">
<meta property="og:image" content="https://shallowshades.github.io.git/2022/07/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220717220746003.png">
<meta property="og:image" content="https://shallowshades.github.io.git/2022/07/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220717220802247.png">
<meta property="og:image" content="https://shallowshades.github.io.git/2022/07/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220717221146483.png">
<meta property="og:image" content="https://shallowshades.github.io.git/2022/07/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220718212016095.png">
<meta property="og:image" content="https://shallowshades.github.io.git/2022/07/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220718221003403.png">
<meta property="og:image" content="https://shallowshades.github.io.git/2022/07/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.assets/image-20220721214326119.png">
<meta property="og:image" content="https://shallowshades.github.io.git/2022/07/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220722013246305.png">
<meta property="og:image" content="https://shallowshades.github.io.git/2022/07/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220722021206221.png">
<meta property="og:image" content="https://shallowshades.github.io.git/2022/07/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220722213156905.png">
<meta property="og:image" content="https://shallowshades.github.io.git/2022/07/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220725211536921.png">
<meta property="og:image" content="https://shallowshades.github.io.git/2022/07/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220725212029932.png">
<meta property="article:published_time" content="2022-07-16T03:06:15.000Z">
<meta property="article:modified_time" content="2022-11-20T15:50:56.892Z">
<meta property="article:author" content="未名">
<meta property="article:tag" content="DesignMode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://shallowshades.github.io.git/2022/07/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220717215938881.png">
  
    <link rel="alternate" href="/atom.xml" title="未名的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">未名的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://shallowshades.github.io.git"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-设计模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/07/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2022-07-16T03:06:15.000Z" itemprop="datePublished">2022-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      设计模式
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>松耦合设计思想 </p>
<p>面向对象设计原则</p>
<p>重构技法改善设计 </p>
<p>GOF 核心设计模式</p>
<p><strong>什么是设计模式</strong> </p>
<p>​    “每一个模式描述了一个在我们周围不断重复发生的问题， 以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动”。 ——Christopher Alexander</p>
<h2 id="设计模式概括"><a href="#设计模式概括" class="headerlink" title="设计模式概括"></a>设计模式概括</h2><h3 id="从面向对象谈起"><a href="#从面向对象谈起" class="headerlink" title="从面向对象谈起"></a>从面向对象谈起</h3><p><strong>底层思维</strong>：向下，如何把握机器底层 从微观理解对象构造 </p>
<p>• 语言构造 </p>
<p>• 编译转换</p>
<p>• 内存模型 </p>
<p>• 运行时机制</p>
<p><strong>抽象思维</strong>：向上，如何将我们的周围 世界抽象为程序代码 </p>
<p>• 面向对象 </p>
<p>• 组件封装 </p>
<p>• 设计模式 </p>
<p>• 架构模式</p>
<h3 id="深入理解面向对象"><a href="#深入理解面向对象" class="headerlink" title="深入理解面向对象"></a>深入理解面向对象</h3><p>向下：深入理解三大面向对象机制 </p>
<p>• 封装，隐藏内部实现 </p>
<p>• 继承，复用现有代码 </p>
<p>• 多态，改写对象行为</p>
<p>向上：深刻把握面向对象机制所带来的抽象意义，理解如何使用 这些机制来表达现实世界，掌握什么是“好的面向对象设计”</p>
<h3 id="软件设计复杂的根本原因：变化"><a href="#软件设计复杂的根本原因：变化" class="headerlink" title="软件设计复杂的根本原因：变化"></a>软件设计复杂的根本原因：<strong>变化</strong></h3><p>• 客户需求的变化 </p>
<p>• 技术平台的变化 </p>
<p>• 开发团队的变化 </p>
<p>• 市场环境的变化</p>
<h3 id="如何解决复杂性？"><a href="#如何解决复杂性？" class="headerlink" title="如何解决复杂性？"></a>如何解决复杂性？</h3><p><strong>分解</strong> </p>
<p>• 人们面对复杂性有一个常见的做法：即分而治之，将大问题分解为多个小问题，将复杂问题分解为多个简单问题。 </p>
<p><strong>抽象</strong> </p>
<p>• 更高层次来讲，人们处理复杂性有一个通用的技术，即抽象。 由于不能掌握全部的复杂对象，我们选择忽视它的非本质细节， 而去处理泛化和理想化了的对象模型。</p>
<h3 id="软件设计的目标：复用"><a href="#软件设计的目标：复用" class="headerlink" title="软件设计的目标：复用"></a>软件设计的目标：复用</h3><p><strong>复用 复用 复用</strong></p>
<h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><h3 id="面向对象设计：抵御变化"><a href="#面向对象设计：抵御变化" class="headerlink" title="面向对象设计：抵御变化"></a>面向对象设计：抵御变化</h3><p>变化是复用的天敌！ 面向对象设计最大的优势在于： <strong>抵御变化</strong>！</p>
<h3 id="重新认识面向对象"><a href="#重新认识面向对象" class="headerlink" title="重新认识面向对象"></a>重新认识面向对象</h3><p>理解隔离变化 </p>
<p>• 从宏观层面来看，面向对象的构建方式更能适应软件的变化， 能将变化所带来的影响减为最小 </p>
<p>各司其职 </p>
<p>• 从微观层面来看，面向对象的方式更强调各个类的“责任” </p>
<p>• 由于需求变化导致的新增类型不应该影响原来类型的实现—— 是所谓各负其责 </p>
<p>对象是什么？ </p>
<p>• 从语言实现层面来看，对象封装了代码和数据。 </p>
<p>• 从规格层面讲，对象是一系列可被使用的公共接口。 </p>
<p>• 从概念层面讲，对象是某种拥有责任的抽象。</p>
<h3 id="依赖倒转原则（DIP）"><a href="#依赖倒转原则（DIP）" class="headerlink" title="依赖倒转原则（DIP）"></a>依赖倒转原则（DIP）</h3><p>• 高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于 抽象(稳定) 。 </p>
<p>• 抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于 抽象(稳定)。</p>
<h3 id="开放封闭原则（OCP）"><a href="#开放封闭原则（OCP）" class="headerlink" title="开放封闭原则（OCP）"></a>开放封闭原则（OCP）</h3><p>• 对扩展开放，对更改封闭。 </p>
<p>• 类模块应该是可扩展的，但是不可修改。</p>
<h3 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h3><p>• 一个类应该仅有一个引起它变化的原因。 </p>
<p>• 变化的方向隐含着类的责任。</p>
<h3 id="Liskov-替换原则（LSP）"><a href="#Liskov-替换原则（LSP）" class="headerlink" title="Liskov 替换原则（LSP）"></a>Liskov 替换原则（LSP）</h3><p>• 子类必须能够替换它们的基类(IS-A)。 </p>
<p>• 继承表达类型抽象。</p>
<h3 id="接口隔离原则（ISP）"><a href="#接口隔离原则（ISP）" class="headerlink" title="接口隔离原则（ISP）"></a>接口隔离原则（ISP）</h3><p>• 不应该强迫客户程序依赖它们不用的方法。 </p>
<p>• 接口应该小而完备。</p>
<p>（该private就private，用不到的不用开放）</p>
<h3 id="优先使用对象组合，而不是类继承"><a href="#优先使用对象组合，而不是类继承" class="headerlink" title="优先使用对象组合，而不是类继承"></a>优先使用对象组合，而不是类继承</h3><p>• 类继承通常为“白箱复用”，对象组合通常为“黑箱复用”。 </p>
<p>• 继承在某种程度上破坏了封装性，子类父类耦合度高。 </p>
<p>• 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。</p>
<h3 id="封装变化点"><a href="#封装变化点" class="headerlink" title="封装变化点"></a>封装变化点</h3><p>• 使用封装来创建对象之间的分界层，让设计者可以在分界层的 一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。</p>
<h3 id="针对接口编程，而不是针对实现编程"><a href="#针对接口编程，而不是针对实现编程" class="headerlink" title="针对接口编程，而不是针对实现编程"></a>针对接口编程，而不是针对实现编程</h3><p>• 不将变量类型声明为某个特定的具体类，而是声明为某个接口。 </p>
<p>• 客户程序无需获知对象的具体类型，只需要知道对象所具有的 接口。 </p>
<p>• 减少系统中各部分的依赖关系，从而实现“高内聚、松耦合” 的类型设计方案。</p>
<h3 id="面向接口设计：接口标准化"><a href="#面向接口设计：接口标准化" class="headerlink" title="面向接口设计：接口标准化"></a>面向接口设计：接口标准化</h3><h3 id="设计原则提升为设计经验"><a href="#设计原则提升为设计经验" class="headerlink" title="设计原则提升为设计经验"></a>设计原则提升为设计经验</h3><ol>
<li><p>设计习语 Design Idioms </p>
<p>  • Design Idioms 描述与特定编程语言相关的低层模式，技巧， 惯用法。 </p>
</li>
<li><p>设计模式 Design Patterns </p>
<p>  • Design Patterns主要描述的是“类与相互通信的对象之间的组 织关系，包括它们的角色、职责、协作方式等方面。 </p>
</li>
<li><p>架构模式 Architectural Patterns </p>
<p>  • Architectural Patterns描述系统中与基本结构组织关系密切的 高层模式，包括子系统划分，职责，以及如何组织它们之间关系的规则。</p>
</li>
</ol>
<h2 id="GOF-23-模式分类"><a href="#GOF-23-模式分类" class="headerlink" title="GOF-23 模式分类"></a>GOF-23 模式分类</h2><p>从<strong>目的</strong>来看： </p>
<p>• 创建型（Creational）模式：将对象的部分创建工作延迟到子类或者其他对象，从而应对需求变化为对象创建时具体类型实现引来的冲击。 </p>
<p>• 结构型（Structural）模式：通过类继承或者对象组合获得更灵活的结构，从而应对需求变化为对象的结构带来的冲击。 </p>
<p>• 行为型（Behavioral）模式：通过类继承或者对象组合来划分类与对象间的职责，从而应对需求变化为多个交互的对象带来的冲击。 </p>
<p>从<strong>范围</strong>来看： </p>
<p>• 类模式处理类与子类的静态关系。</p>
<p>• 对象模式处理对象间的动态关系。 </p>
<p>从<strong>封装变化</strong>角度对模式分类</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220717215938881.png" alt="image-20220717215938881"></p>
<h2 id="重构获得模式-Refactoring-to-Patterns"><a href="#重构获得模式-Refactoring-to-Patterns" class="headerlink" title="重构获得模式 Refactoring to Patterns"></a>重构获得模式 Refactoring to Patterns</h2><p>面向对象设计模式是“好的面向对象设计”，所谓“好的面向对 象设计”指是那些可以满足 “应对变化，提高复用”的设计 。 </p>
<p>现代软件设计的特征是“需求的频繁变化”。设计模式的要点是 “寻找变化点，然后在变化点处应用设计模式，从而来更好地应对 需求的变化”.“什么时候、什么地点应用设计模式”比“理解设 计模式结构本身”更为重要。 </p>
<p>设计模式的应用不宜先入为主，一上来就使用设计模式是对设计 模式的最大误用。没有一步到位的设计模式。敏捷软件开发实践提 倡的“Refactoring to Patterns”是目前普遍公认的最好的使用设 计模式的方法。</p>
<h2 id="重构关键技法"><a href="#重构关键技法" class="headerlink" title="重构关键技法"></a>重构关键技法</h2><p><strong>静态 -&gt; 动态</strong> </p>
<p><strong>早绑定  -&gt; 晚绑定</strong> </p>
<p><strong>继承  -&gt;  组合</strong> </p>
<p><strong>编译时依赖  -&gt; 运行时依赖</strong> </p>
<p><strong>紧耦合  -&gt;  松耦合</strong></p>
<h2 id="“组件协作”模式"><a href="#“组件协作”模式" class="headerlink" title="“组件协作”模式"></a>“组件协作”模式</h2><p>现代软件专业分工之后的第一个结果是“框架与应用程序的划分”，“组件协作”模式通过晚期绑定，来实现框架与应用程序之间的松耦合，是二者之间协作时常用的模式。 </p>
<p>典型模式 </p>
<p>• Template Method </p>
<p>• Observer / Event </p>
<p>• Strategy</p>
<h2 id="Template-Method"><a href="#Template-Method" class="headerlink" title="Template Method"></a>Template Method</h2><h3 id="动机（Motivation）"><a href="#动机（Motivation）" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h3><p>在软件构建过程中，对于某一项任务，它常常有稳定的整体操作 结构，但各个子步骤却有很多改变的需求，或者由于固有的原因 （比如框架与应用之间的关系）而无法和任务的整体结构同时实现。 </p>
<p>如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求？</p>
<p><strong>将变化的部分设为纯虚函数，在子类中实现</strong></p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220717220730182.png" alt="image-20220717220730182"></p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220717220746003.png" alt="image-20220717220746003"></p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220717220802247.png" alt="image-20220717220802247"></p>
<p><strong>C++实现晚绑定的方式是虚函数</strong></p>
<p><strong>C实现晚绑定的方式是函数指针</strong></p>
<h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p>定义一个操作中的算法的骨架 (稳定)，而将一些步骤延迟 (变化)到子类中。Template Method使得子类可以不改变 (复用)一个算法的结构即可重定义(override 重写)该算法的某些特定步骤。                 ——《设计模式》GoF</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220717221146483.png" alt="image-20220717221146483"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Template Method模式是一种非常基础性的设计模式，在面向对象系统中有着大量的应用。它用最简洁的机制（虚函数的多态性） 为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构。 </p>
<p>除了可以灵活应对子步骤的变化外，“<strong>不要调用我，让我来调用你</strong>”的反向控制结构是Template Method的典型应用。 </p>
<p>在具体实现方面，被Template Method调用的虚方法可以具有实现，也可以没有任何实现（抽象方法、纯虚方法），但一般推荐将它们设置为protected方法。</p>
<h2 id="Strategy-策略模式"><a href="#Strategy-策略模式" class="headerlink" title="Strategy 策略模式"></a>Strategy 策略模式</h2><h3 id="动机（Motivation）-1"><a href="#动机（Motivation）-1" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h3><p>在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂； 而且有时候支持不使用的算法也是一个性能负担。 </p>
<p>如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？</p>
<h3 id="模式定义-1"><a href="#模式定义-1" class="headerlink" title="模式定义"></a>模式定义</h3><p>定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序(稳定)而变化（扩展，子类化）。                                                                                                                                                         ——《设计模式》GoF</p>
<h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220718212016095.png" alt="image-20220718212016095"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换。 </p>
<p>Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需要Strategy模式。 </p>
<p>如果Strategy对象没有实例变量，那么各个上下文可以共享同一个 Strategy对象，从而节省对象开销。</p>
<h2 id="Observer-观察者模式（Event）"><a href="#Observer-观察者模式（Event）" class="headerlink" title="Observer 观察者模式（Event）"></a>Observer 观察者模式（Event）</h2><h3 id="动机（Motivation）-2"><a href="#动机（Motivation）-2" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h3><p>在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系” ——一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密， 将使软件不能很好地抵御变化。 </p>
<p>使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。</p>
<h3 id="模式定义-2"><a href="#模式定义-2" class="headerlink" title="模式定义"></a>模式定义</h3><p>定义对象间的一种一对多（变化）的依赖关系，以便当一个对象(Subject)的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。                                                                                                                                                                                     ——《设计模式》GoF</p>
<h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220718221003403.png" alt="image-20220718221003403"></p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><strong>我们订阅你（加入圈子），你有动态就发送到（圈子），我们按照各自的方式收到通知</strong></p>
<p>使用面向对象的抽象，Observer模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖关系达致松耦合。 </p>
<p>目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。 </p>
<p>观察者自己决定是否需要订阅通知，目标对象对此一无所知。 </p>
<p>Observer模式是基于事件的UI框架中非常常用的设计模式，也是MVC模式的一个重要组成部分。</p>
<h2 id="“单一职责”模式"><a href="#“单一职责”模式" class="headerlink" title="“单一职责”模式"></a>“单一职责”模式</h2><p>在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码， 这时候的关键是划清责任。 </p>
<p>典型模式 </p>
<p>• Decorator </p>
<p>• Bridge</p>
<h2 id="Decorator-装饰模式"><a href="#Decorator-装饰模式" class="headerlink" title="Decorator 装饰模式"></a>Decorator 装饰模式</h2><h3 id="动机（Motivation）-3"><a href="#动机（Motivation）-3" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h3><p>在某些情况下我们可能会“过度地使用继承来扩展对象的功能” ， 由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性； 并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展 功能的组合）会导致更多子类的膨胀。 </p>
<p>如何使“对象功能的扩展”能够根据需要来动态地实现？同时避 免“扩展功能的增多”带来的子类膨胀问题？从而使得任何“功能 扩展变化”所导致的影响将为最低？</p>
<h3 id="模式定义-3"><a href="#模式定义-3" class="headerlink" title="模式定义"></a>模式定义</h3><p>动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（<strong>消除重复代码 &amp; 减少子类个数</strong>）。                                                                                                                                                                     ——《设计模式》GoF</p>
<h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><p><img src="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.assets/image-20220721214326119.png" alt="image-20220721214326119"></p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><strong>继承和组合同时使用</strong></p>
<p>通过采用组合而非继承的手法， Decorator模式实现了在运行时 动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的“灵活性差”和“多子类衍生问题” 。 </p>
<p>Decorator类在接口上表现为is-a Component的继承关系，即 Decorator类继承了Component类所具有的接口。但在实现上又表现为has-a Component的组合关系，即Decorator类又使用了 另外一个Component类。 </p>
<p>Decorator模式的目的并非解决“多子类衍生的多继承”问题， Decorator模式应用的要点在于解决“主体类在多个方向上的扩展功能”——是为“装饰”的含义。</p>
<h2 id="Bridge-桥模式"><a href="#Bridge-桥模式" class="headerlink" title="Bridge 桥模式"></a>Bridge 桥模式</h2><h3 id="动机（Motivation）-4"><a href="#动机（Motivation）-4" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h3><p>由于某些类型的固有的实现逻辑，使得它们具有两个变化的维度， 乃至多个纬度的变化。 </p>
<p>如何应对这种“多维度的变化”？如何利用面向对象技术来使得 类型可以轻松地沿着两个乃至多个方向变化，而不引入额外的复杂度？</p>
<h3 id="模式定义-4"><a href="#模式定义-4" class="headerlink" title="模式定义"></a>模式定义</h3><p>将抽象部分(业务功能)与实现部分(平台实现)分离，使它们都可以独立地变化。                                                     ——《设计模式》GoF</p>
<h3 id="结构（Structure）"><a href="#结构（Structure）" class="headerlink" title="结构（Structure）"></a>结构（Structure）</h3><p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220722013246305.png" alt="image-20220722013246305"></p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固 有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自纬度的变化，即“子类化”它们。 </p>
<p>Bridge模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则（即一个类只有一个变化的原因），复用性比较差。 Bridge模式是比多继承方案更好的解决方法。 </p>
<p>Bridge模式的应用一般在“两个非常强的变化维度”，有时一个 类也有多于两个的变化维度，这时可以使用Bridge的扩展模式。</p>
<h2 id="“对象创建”模式"><a href="#“对象创建”模式" class="headerlink" title="“对象创建”模式"></a>“对象创建”模式</h2><p>通过“对象创建” 模式绕开new，来避免对象创建（new）过程 中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。 </p>
<p>典型模式 </p>
<p>•Factory Method </p>
<p>•Abstract Factory </p>
<p>•Prototype </p>
<p>•Builder</p>
<h2 id="Factory-Method工厂方法"><a href="#Factory-Method工厂方法" class="headerlink" title="Factory Method工厂方法"></a>Factory Method工厂方法</h2><h3 id="动机（Motivation）-5"><a href="#动机（Motivation）-5" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h3><p>在软件系统中，经常面临着创建对象的工作；由于需求的变化， 需要创建的对象的具体类型经常变化。 </p>
<p>如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一 种“封装机制”来避免客户程序和这种“具体对象创建工作”的紧耦合？</p>
<h3 id="模式定义-5"><a href="#模式定义-5" class="headerlink" title="模式定义"></a>模式定义</h3><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。 Factory Method使得一个类的实例化延迟（目的：解耦， 手段：虚函数）到子类。                                                                                                                                                                             ——《设计模式》GoF</p>
<h3 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h3><p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220722021206221.png" alt="image-20220722021206221"></p>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>Factory Method模式用于隔离类对象的使用sw者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导致软件的脆弱。 </p>
<p>Factory Method模式通过面向对象的手法，将所要创建的具体对象工作延迟到子类，从而实现一种扩展（而非更改）的策略，较好地解决了这种紧耦合关系。 </p>
<p>Factory Method模式解决“单个对象”的需求变化。缺点在于要求创建方法/参数相同。</p>
<h2 id="Abstract-Factory-抽象工厂"><a href="#Abstract-Factory-抽象工厂" class="headerlink" title="Abstract Factory 抽象工厂"></a>Abstract Factory 抽象工厂</h2><h3 id="动机（Motivation）-6"><a href="#动机（Motivation）-6" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h3><p>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时，由于需求的变化，往往存在更多系列对象的创建工作。 </p>
<p>如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一 种“封装机制”来避免客户程序和这种“多系列具体对象创建工作” 的紧耦合?</p>
<h3 id="模式定义-6"><a href="#模式定义-6" class="headerlink" title="模式定义"></a>模式定义</h3><p>提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们具体的类。                            ——《设计模式》GoF</p>
<h3 id="结构（Structure）-1"><a href="#结构（Structure）-1" class="headerlink" title="结构（Structure）"></a>结构（Structure）</h3><p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220722213156905.png" alt="image-20220722213156905"></p>
<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>如果没有应对“多系列对象构建”的需求变化，则没有必要使用 Abstract Factory模式，这时候使用简单的工厂完全可以。 </p>
<p>“系列对象”指的是在某一特定系列下的对象之间有相互依赖、 或作用的关系。不同系列的对象之间不能相互依赖。 </p>
<p>Abstract Factory模式主要在于应对“新系列”的需求变动。其缺点在于难以应对“新对象”的需求变动。</p>
<h2 id="Prototype-模式"><a href="#Prototype-模式" class="headerlink" title="Prototype 模式"></a>Prototype 模式</h2><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>在软件系统中，经常面临着“某些结构复杂的对象”的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是它们却拥有比较稳定一致的接口。</p>
<p>如何应对这种变化？如何向“客户程序（使用这些对象的程序）”隔离出“这些易变对象”，从而使得“依赖这些易变对象的客户端程序”不随着需求改变而改变？</p>
<h3 id="模式定义-7"><a href="#模式定义-7" class="headerlink" title="模式定义"></a>模式定义</h3><p>使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。                                        ——《设计模式》 GoF</p>
<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>Prototype模式同样用于隔离类对象的使用者和具体类型(易变类)之间的耦合关系，它同样要求这些“易变类拥有“稳定的接口”。</p>
<p>Prototype模式对于“如何创建易变类的实体对象”采用“原型克隆”的方法来做，它使得我们可以非常灵活地动态创建‘拥有某些稳定接口”的新对象——所需工作仅仅是注册一个新类的对象(即原型)，然后在任何需要的地方Clone。</p>
<p>Prototype模式中的Clone方法可以利用某些框架中的序列化来实现深拷贝。</p>
<h2 id="Builder-构建器"><a href="#Builder-构建器" class="headerlink" title="Builder 构建器"></a>Builder 构建器</h2><h3 id="动机（Motivation）-7"><a href="#动机（Motivation）-7" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h3><p>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p>
<p>如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂 对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？</p>
<h3 id="模式定义-8"><a href="#模式定义-8" class="headerlink" title="模式定义"></a>模式定义</h3><p>将一个复杂对象的构建与其表示相分离，使得同样的构建过程(稳定)可以创建不同的表示(变化)。                     ——《设计模式》GoF</p>
<h3 id="结构（Structure）-2"><a href="#结构（Structure）-2" class="headerlink" title="结构（Structure）"></a>结构（Structure）</h3><p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220725211536921.png" alt="image-20220725211536921"></p>
<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>Builder 模式主要用于“分步骤构建一个复杂的对象”。在这其中 “分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化。 </p>
<p>变化点在哪里，封装哪里—— Builder模式主要在于应对“复杂对 象各个部分”的频繁需求变动。其缺点在于难以应对“分步骤构建 算法”的需求变动。 </p>
<p>在Builder模式中，要注意不同语言中构造器内调用虚函数的差别 （C++ vs. C#) </p>
<h2 id="“对象性能”-模式"><a href="#“对象性能”-模式" class="headerlink" title="“对象性能” 模式"></a>“对象性能” 模式</h2><p>面向对象很好地解决了”抽象” 的问题，但是必不可免地要付出一定的代价。 对于通常情况来讲,面向对象的成本大都可以忽略不计。但是某些情况,面向对象所带来的成本必须谨慎处理。</p>
<p>典型模式:</p>
<p>·Singleton<br>·Flyweight</p>
<h2 id="Singleton单件模式"><a href="#Singleton单件模式" class="headerlink" title="Singleton单件模式"></a>Singleton单件模式</h2><h3 id="动机-Motivation"><a href="#动机-Motivation" class="headerlink" title="动机( Motivation )"></a>动机( Motivation )</h3><p>在软件系统中,经常有这样一些特殊的类，必须保证它们在系统中只存在一个实例,才能确保它们的逻辑正确性、以及良好的效率。<br>如何绕过常规的构造器,提供-一种机制来保证一个类只有一个实例?</p>
<p>这应该是类设计者的责任,而不是使用者的责任。</p>
<h3 id="模式定义-9"><a href="#模式定义-9" class="headerlink" title="模式定义"></a>模式定义</h3><p>保证一个类仅有一个实例 ,并提供一个该实例的全局访问点。                                                                            一《设计模式》GoF .</p>
<h3 id="结构-5"><a href="#结构-5" class="headerlink" title="结构"></a>结构</h3><p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220725212029932.png" alt="image-20220725212029932"></p>
<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><p>Singleton模式中的实例构造器可以设置为protected以允许子类派生。</p>
<p>Singleton模式一般不要支持拷贝构造函数和Clone接口, 因为这有可能导致多个对象实例,与Singleton模式的初衷违背。</p>
<p>如何实现多线程环境下安全的Singleton ?注意对双检查锁的正确实现。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shallowshades.github.io.git/2022/07/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" data-id="clca7m494002qxog0d5fh8wee" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DesignMode/" rel="tag">DesignMode</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/09/08/git/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          git
        
      </div>
    </a>
  
  
    <a href="/2022/06/22/C++%E8%BF%9B%E9%98%B6/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">C++杂项</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DesignMode/" rel="tag">DesignMode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaWeb/" rel="tag">JavaWeb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/database/" rel="tag">database</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/" rel="tag">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/net/" rel="tag">net</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/C/" style="font-size: 20px;">C++</a> <a href="/tags/DesignMode/" style="font-size: 10px;">DesignMode</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/JavaWeb/" style="font-size: 10px;">JavaWeb</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Web/" style="font-size: 10px;">Web</a> <a href="/tags/database/" style="font-size: 15px;">database</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/go/" style="font-size: 10px;">go</a> <a href="/tags/golang/" style="font-size: 10px;">golang</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/net/" style="font-size: 10px;">net</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">十二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/12/13/Linux/">Linux</a>
          </li>
        
          <li>
            <a href="/2022/12/13/Redis/">Redis</a>
          </li>
        
          <li>
            <a href="/2022/12/13/ginchat/">ginchat</a>
          </li>
        
          <li>
            <a href="/2022/12/13/go/">Go</a>
          </li>
        
          <li>
            <a href="/2022/09/08/git/">git</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 未名<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>